#+title: Audio APIs, Part 3: WASAPI / Windows
#+date: <2017-07-10 14:12>

This is part three of a three-part series on the native audio APIs for Windows, Linux, and macOS. This third part is about WASAPI on Windows.

It has long been a major frustration for my work that Python does not have a great package for playing and recording audio. My first step to improve this situation was a small contribution to [[https://people.csail.mit.edu/hubert/pyaudio/][PyAudio]], a CPython extension that exposes the C library [[http://www.portaudio.com/][PortAudio]] to Python. However, I soon realized that PyAudio mirrors PortAudio's C API a bit too closely for comfort. Thus, I set out to write [[https://github.com/bastibe/PySoundCard][PySoundCard]], which is a higher-level wrapper for PortAudio that tries to be more pythonic and uses NumPy arrays instead of untyped ~bytes~ buffers for audio data. However, I then realized that PortAudio itself had some inherent problems that a wrapper would not be able to solve, and a truly great solution would need to do it the hard way:

Instead of relying on PortAudio, I would have to use the native audio APIs of the three major platforms directly, and implement a simple, cross-platform, high-level, NumPy-aware Python API myself. This effort resulted in [[https://github.com/bastibe/Python-Audio][PythonAudio]], a new pure-Python package that uses [[http://cffi.readthedocs.io/en/latest/][CFFI]] to talk to [[https://www.freedesktop.org/wiki/Software/PulseAudio/][PulseAudio]] on Linux, [[https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/Introduction/Introduction.html][Core Audio]] on macOS, and [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd371455(v=vs.85).aspx][WASAPI]][1] on Windows.

This series of blog posts summarizes my experiences with these three APIs and outlines the basic structure of how to use them. For reference, the singular use case in PythonAudio is block-wise playing/recording of ~float~ data at arbitrary sampling rates and block sizes. All available sound cards should be listable and selectable, with correct detection of the system default sound cards (a feature that is very unreliable in PortAudio).

[1]: WASAPI is part of the Windows [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd370784(v=vs.85).aspx][Core Audio]] APIs. To avoid confusion with the macOS API of the same name, I will always to refer to it as WASAPI.


------------------------------------------------------------------------------

* WASAPI

WASAPI is one of several native audio libraries in Windows. PortAudio actually [[http://portaudio.com/docs/v19-doxydocs/compile_windows.html][supports five of them]]: [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd743883(v=vs.85).aspx][Windows Multimedia (MME)]], the first built-in audio API for Windows 3.1x; [[https://msdn.microsoft.com/en-us/library/windows/desktop/ee416960(v=vs.85).aspx][DirectSound]], the audio subsystem of DirectX for Windows 95;  [[https://docs.microsoft.com/en-us/windows-hardware/drivers/stream/kernel-streaming][Windows Driver Model / Kernel Streaming (WDM/KS)]], the improved audio system for Windows 98; [[https://en.wikipedia.org/wiki/Audio_Stream_Input/Output][ASIO]], a third-party API developed by Steinberg to make pro audio possible on Windows; and finally, [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd370784(v=vs.85).aspx][Windows Audio Session API (WASAPI)]], introduced in Windows Vista to bring a modern audio API to Windows.

In other words, audio on Windows has a long and troubled history, and has had a lot of opportunity for experimentation. It should then be no surprise that WASAPI is a clean and well-documented audio API that avoids many of the pitfalls of its predecessors and brethren. After having experienced the audio APIs of Windows, Linux, and macOS, I am beginning to understand why some programmers love Windows.

But let's take a step back, and give an overview over the API. First of all, this is a cross-language API that is meant to be used from C#, with a solid bridge for C++, and a somewhat funky bridge for C. This is crucial to understand. The whole API is designed for a high-level, object-oriented runtime, but I am accessing it from a low-level language that has no concept of objects, methods, or exceptions.

Objects are implemented as pointers to opaque structs, with an associated list of function pointers to methods. Every method accepts the object pointer as its first argument, and returns an error value if an exception occurred. Both inputs and outputs are function arguments, with outputs being implemented as pointer-to-pointer values. While this looks convoluted to a C programmer, it is actually a very clean mapping of object oriented concepts to C that never gave me any headaches.

However, there are a few edge cases that did take me a while to understand: Since the C API is inherently not polymorphic, you sometimes have to manually specify types as cryptic UUID structs. Figuring out how to convert the UUID strings from the header files to such structs was not easy.  Similarly, it took me a while to reverse-engineer that strings in Windows are actually ~uint16~, despite being declared ~char~. But issues such as these are to be expected in a cross-language API.

In general, I did not find a good overview on how to interpret high-level C#-concepts in C. For example, it took a long time until I learned that objects in C# are reference counted, and that I would have to manage reference counts manually. Similarly, I had one rather thorny issue with memory allocations: in rare occasions (~PROPVARIANT~), C# is expected to re-allocate memory of an object if the object does not have enough memory when passed into a method. This does not work as intended if you don't use C#'s memory allocator to create the memory. /This/ was really painful to figure out.

Another result of the API's cross-language heritage are its headers: There are /hundreds/. And they all contain both the C API and the C++ API, separated by the occasional ~#ifdef __cplusplus~ and ~extern C~. Worse yet, pretty much every data type and declaration is wrapped in multiple levels of preprocessor macros and ~typedef~. There are no doubt good reasons and a rich history for this, but it took me many hours to assemble all the necessary symbols from dozens of header files to even begin to call WASAPI functions.

Nevertheless, once these hurdles are overcome, the actual WASAPI API itself is well-structured and reasonably simple. You acquire an ~IMMDeviceEnumerator~, which returns ~IMMDeviceCollections~ for microphones and speakers. These contain ~IMMDevices~, which represent sound cards and their properties. You activate an ~IMMDevice~ with a desired data format to get an ~IAudioClient~, which in turns produces an ~IAudioRenderClient~ or ~IAudioCaptureClient~ for playback or recording, respectively. Playback and recording themselves are done by requesting a buffer, and reading or writing raw data to that buffer. This is about as straight-forward as APIs get.

The documentation deserves even more praise: I have rarely seen such a well-documented API. There are high-level overview articles, there is commented example code, every object is described abstractly, and every method is described in detail and in reference to related methods and example code. There is no corner case that is left undescribed, and no error code without a detailed explanation. Truly, this is /exceptional/ documentation that is a joy to work with!

In conclusion, WASAPI leaves me in a situation I am very unfamiliar with: praising Windows. There is a non-trivial impedance mismatch between C and C# that has to be overcome to /use/ WASAPI from C. But once I understood this, the API itself and its documentation were easy to use and understand. Impressive!
