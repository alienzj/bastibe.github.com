#+title: Audio APIs, Part 1: Core Audio / macOS
#+date: <2017-06-17 14:45>

This is part one of a three-part series on the native audio APIs for Windows, Linux, and macOS. This first part is about Core Audio on macOS.

It has long been a major frustration for my work that Python does not have a great package for playing and recording audio. My first step to improve this situation were a small contribution to [[https://people.csail.mit.edu/hubert/pyaudio/][PyAudio]], a CPython extension that exposes the C library [[http://www.portaudio.com/][PortAudio]] to Python. However, I soon realized that PyAudio mirrors PortAudio a bit too closely for comfort. Thus, I set out to write [[https://github.com/bastibe/PySoundCard][PySoundCard]], which is a higher-level wrapper for PortAudio that tries to be more pythonic and uses NumPy arrays instead of untyped ~bytes~ buffers for audio data. However, I then realized that PortAudio itself had some inherent problems that a wrapper would not be able to solve, and a truly great solution would need to do it the hard way:

Instead of relying on PortAudio, I would have to use the native audio APIs of the three major platforms directly, and implement a simple, cross-platform, high-level, NumPy-aware Python API myself. This effort resulted in [[https://github.com/bastibe/Python-Audio][PythonAudio]], a new pure-Python package that uses [[http://cffi.readthedocs.io/en/latest/][CFFI]] to talk to [[https://www.freedesktop.org/wiki/Software/PulseAudio/][PulseAudio]] on Linux, [[https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/Introduction/Introduction.html][Core Audio]] on macOS, and [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd371455(v=vs.85).aspx][WASAPI]][1] on Windows.

This series of blog posts summarizes my experiences with these three APIs and outlines the basic structure of how to use them. For reference, the singular use case in PythonAudio is playing/recording of short blocks of ~float~ data at arbitrary sampling rates and block sizes. All connected sound cards should be listable and selectable, with correct detection of the system default sound card (a feature that is very unreliable in PortAudio).

[1]: WASAPI is part of the Windows [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd370784(v=vs.85).aspx][Core Audio]] APIs. To avoid confusion with the macOS API of the same name, I will always to refer to it as WASAPI.


------------------------------------------------------------------------------

** CoreAudio, or the Mac's best kept secret

CoreAudio is the native audio library for macOS. It is known for its high performance, low latency, and horrible documentation. After having used the native audio APIs on all three platforms, CoreAudio was /by far/ the hardest one to use. The main problem is lack of documentation and lack of feedback, and plain missing or broken features. Let's get started.

The basic unit of any CoreAudio program is the audio unit. An audio unit can be a source (aka microphone), a sink (aka speaker) or an audio processor (both sink and source). Each audio unit can have several input /buses/, and several output /buses/, each of which can have several /channels/. The meaning of these buses varies wildly and is often underdocumented. Furthermore, every audio unit has several /properties/, such as a sample rate, block sizes, and a data format, and /parameters/, which are like properties, but presumably different in some undocumented way.

In order to use an audio unit, you create an ~AudioComponentDescription~ that describes whether you want a source or sink unit, or an effect unit, and what kind of effect you want (AudioComponent is an alternative name for audio unit). With the description, you can create an ~AudioComponentInstance~, which is then an opaque struct pointer to your newly created audio unit. So far so good.

The next step is then to configure the audio unit using ~AudioUnitGetProperty~ and ~AudioUnitSetProperty~. This is surprisingly hard, since every property can be configured for every bus (sometimes called element) of every input or output of every unit, and the documentation is extremely terse on which of these combinations are valid. Some invalid combinations return error codes, while others only lead to errors during playback/recording. Furthermore, the definition of what constitutes an input or output is interpreted quite differently in different places: One place calls a microphone an /input/, since it records audio; another place will call it an /output/, since it outputs audio data to the system. In one crazy example, you have to configure a microphone unit by disabling its output bus 0, and enabling its input bus 1, but then read audio data from its ostensibly disabled output bus 0.

The property interface is untyped, meaning that every property has to be given an identifier, a void pointer that points to a matching data structure, and the size of that data structure. Sometimes the setter allocates additional memory, in which case the documentation does not contain any information on who should free this memory. Most objects are passed around as opaque struct pointers with dedicated constructor and destructor functions. All of this does not strike me as particularly C-like, even though CoreAudio is supposedly a native C library.

Once your audio unit is configured, you set a render callback function, and start the audio unit. All important interaction now happens within that callback function. In a strange reversal of typical control flow, input data to the callback function needs to be fetched by calling ~AudioUnitRender~ (evoked on the unit itself) from within the callback, while output is written to memory provided as callback function arguments. Many times during development, ~AudioUnitRender~ would return error codes because of an invalid property setting during initialization. Of course, it won't tell /which/ property is actually at fault, just that it can't fulfill the render request at the moment.

Error codes in general are a difficult topic in CoreAudio. Most functions return an error code as an ~OSStatus~ value (aka ~uint32~), and the header files usually contain a definition of some, but not all, possible error codes. Sometimes these error codes are descriptive and nice, but often they are way too general. My favorite is the frequent ~kAudioUnitErr_CannotDoInCurrentContext~, which is just about as useless an error description as possible. Worse, some error codes are not defined as numeric constants, but as ~int err = 'abcd'~, which makes them un-searchable in the source file. Luckily, this madness can be averted using [[https://osstatus.com/]], which is a dedicated database for ~OSStatus~ error codes.

By far the worst part of the CoreAudio API is that some properties are silently ignored. For example, you can set the sample rate or priming information on a microphone unit, and it will accept that property change and it will report that property as changed, but it will still use its default value when recording (aka "rendering" in CoreAudio). A speaker unit, in contrast, will honor the sample rate property, and resample as necessary. If you still need to resample your microphone recordings, you have to use a separate ~AudioConverter~ unit, which is its own bag of fun (and only documented in [[https://developer.apple.com/library/content/technotes/tn2091/_index.html#//apple_ref/doc/uid/DTS10003118-CH1-FORMATS][a remark]] in one overview document).

Lastly, all the online documentation is written for Swift and Objective-C, while the implementation is C. Worse, the C headers contain vastly more information than the online documentation, and the online documentation often does not even reference the C header file name. Of course header files are spread into the CoreAudio framework, the AudioToolkit framework, and the AudioUnit framework, which makes even grepping a joy.

All of that said, once you know what to do and how to do it, the resulting code is relatively compact and readable. The API does contain inconsistencies and questionable design choices, but the real problem is the documentation. I spent way too much time reading the header files over and over again, and searching through (often outdated or misleading) [[https://developer.apple.com/library/content/samplecode/AVCaptureToAudioUnitOSX/Listings/CaptureSessionController_mm.html#//apple_ref/doc/uid/DTS40012879-CaptureSessionController_mm-DontLinkElementID_4][example projects]] and [[https://developer.apple.com/library/content/technotes/tn2091/_index.html#//apple_ref/doc/uid/DTS10003118-CH1-FORMATS][vague]] [[https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/AudioUnitDevelopmentFundamentals/AudioUnitDevelopmentFundamentals.html#//apple_ref/doc/uid/TP40003278-CH7-SW12][high-level]] [[https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003278-CH1-SW2][overviews]] for clues on how to interpret error messages and API documentation. I had somewhat better luck with a few [[http://kaniini.dereferenced.org/2014/08/31/CoreAudio-sucks.html][blog]] [[http://subfurther.com/blog/2009/04/28/an-iphone-core-audio-brain-dump/][posts]] on the subject, but the general consensus seems to be that the main concepts of CoreAudio are woefully under-explained, and documentation about edge cases is almost nonexistent. Needless to say, I did not enjoy my experience with CoreAudio.
