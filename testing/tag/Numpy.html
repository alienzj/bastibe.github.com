<!doctype html>
<html> <head> <title>Bastis Scratchpad on the Internet</title> <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" /> <link href= "http://bastibe.de/testing//css/style.css" rel="stylesheet" type="text/css" /> <link rel="alternate" href="http://bastibe.de/testing//rss.xml" type="application/rss+xml" /> <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: { inlineMath: [["$","$"]] }});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </head> <body> <div class="navigation"> <a href="http://bastibe.de/testing/">Bastis Scratchpad on the Internet</a> | <a href="http://alpha.app.net/bastibe">alpha.app.net</a>  | <a href="http://github.com/bastibe">Github</a>  </div> <div id="content"> <div class="article-meta"> <a class="article-title" href="http://bastibe.de/testing//posts/Real-Time-Signal-Processing-in-Python.html">Real Time Signal Processing in Python</a> <div class="date"> posted on 2012-11-02 10:53</div> <div class="article">

<p>Wouldn't it be nice if you could do real time audio processing in a convenient programming language? Matlab comes to mind as a convenient language for signal processing. But while Matlab is pretty fast, it is really only fast for algorithms that can be vectorized. In audio however, we have many algorithms that need knowledge about the previous sample to calculate the next one, so they can't be vectorized.</p>

<p>But this is not going to be about Matlab. This is going to be about Python. Combine Python with Numpy (and Scipy and Matplotlib) and you have a signal processing system very comparable to Matlab. Additionally, you can do real-time audio input/output using PyAudio. PyAudio is a wrapper around PortAudio and provides cross platform audio recording/playback in a nice, pythonic way. (Real time capabilities were added in 0.2.6 with the help of yours truly).</p>

<p>However, this does not solve the problem with vectorization. Just like Matlab, Python/Numpy is only fast for vectorizable algorithms. So as an example, let's define an iterative algorithm that is not vectorizable:</p>

<h2>A Simple Limiter</h2>

<p>A limiter is an audio effect that controls the system gain so that it does not exceed a certain threshold level. One could do this by simply cutting off any signal peaks above that level, but that sounds awful. So instead, the whole system gain is reduced smoothly if the signal gets too loud and is amplified back to its original gain again when it does not exceed the threshold any more. The important part is that the gain change is done <em>smoothly</em>, since otherwise it would introduce a lot of distortion.</p>

<p>If a signal peak is detected, the limiter will thus need a certain amount of time to reduce the gain accordingly. If you still want to prevent all peaks, the limiter will have to know of the peaks in advance, which is of course impossible in a real time system. Instead, the signal is delayed by a short time to give the limiter time to adjust the system gain before the peak is actually played. To keep this delay as short as possible, this &quot;attack&quot; phase where the gain is decreased should be very short, too. &quot;Releasing&quot; the gain back up to its original value can be done more slowly, thus introducing less distortion.</p>

<p>With that out of the way, let me present you a simple implementation of such a limiter. First, lets define a signal envelope $e[n]$ that catches all the peaks and smoothly decays after them:</p>

<p>$ e[n] = \max( |s[n]|, e[n-1] \cdot f_r ) $</p>

<p>where $s[n]$ is the current signal and $0 &lt; f_r &lt; 1$ is a release factor.</p>

<p>If this is applied to a signal, it will create an envelope like this:</p>

<p><img src="images/2012-11/envelope.png" alt="Envelope" /></p>

<p>Based on that envelope, and assuming that the signal ranges from -1 to 1, the target gain $g_t[n]$ can be calculated using</p>

<p>\begin{equation}
g_t[n] = \begin{cases}
    1 &amp; e[n] &lt; t \\
    1 + t - e[n] &amp; e[n] &gt; t
\end{cases}
\end{equation}</p>

<p>Now, the output gain $g[n]$ can smoothly move towards that target gain using</p>

<p>$ g[n] = g[n-1] \cdot f_a + g_t[n] \cdot (1-f_a) $</p>

<p>where $0 &lt; f_a \ll f_r$ is the attack factor.</p>

<p>Here you can see how that would look in practice:</p>

<p><img src="images/2012-11/gain.png" alt="Gain" /></p>

<p>Zooming in on one of the limited section reveals that the gain is actually moving smoothly.</p>

<p><img src="images/2012-11/detail.png" alt="Detail Gain" /></p>

<p>This gain can now be multiplied on the delayed input signal and will safely keep that below the threshold.</p>

<p>In Python, this might look like this:</p>

<pre><code><span class="code">    <span class="special">class</span><span
class="keyword"> Limiter</span>:
        <span class="special">def</span><span
class="keyword"> __init__</span><span class="paren1">(<span class="code">self, attack_coeff, release_coeff, delay, dtype=float32</span>)</span>:
            self.delay_index = 0
            self.envelope = 0
            self.gain = 1
            self.delay = delay
            self.delay_line = zeros<span class="paren1">(<span class="code">delay, dtype=dtype</span>)</span>
            self.release_coeff = release_coeff
            self.attack_coeff = attack_coeff
    
        <span class="special">def</span><span
class="keyword"> limit</span><span class="paren1">(<span class="code">self, signal, threshold</span>)</span>:
            <span class="symbol">for</span> i <span class="symbol">in</span> arange<span class="paren1">(<span class="code">len<span class="paren2">(<span class="code">signal</span>)</span></span>)</span>:
                self.delay_line<span class="paren1">[<span class="code">self.delay_index</span>]</span> = signal<span class="paren1">[<span class="code">i</span>]</span>
                self.delay_index = <span class="paren1">(<span class="code">self.delay_index + 1</span>)</span> % self.delay
    
                <span class="comment"># calculate an envelope of the signal
</span>                self.envelope *= self.release_coeff
                self.envelope  = max<span class="paren1">(<span class="code">abs<span class="paren2">(<span class="code">signal<span class="paren3">[<span class="code">i</span>]</span></span>)</span>, self.envelope</span>)</span>
    
                <span class="comment"># have self.gain go towards a desired limiter gain
</span>                <span class="symbol">if</span> self.envelope &gt; threshold:
                    target_gain = <span class="paren1">(<span class="code">1+threshold-self.envelope</span>)</span>
                else:
                    target_gain = 1.0
                self.gain = <span class="paren1">(<span class="code"> self.gain*self.attack_coeff +
                              target_gain*<span class="paren2">(<span class="code">1-self.attack_coeff</span>)</span> </span>)</span>
    
                <span class="comment"># limit the delayed signal
</span>                signal<span class="paren1">[<span class="code">i</span>]</span> = self.delay_line<span class="paren1">[<span class="code">self.delay_index</span>]</span> * self.gain</span></code></pre>

<p>Note that this limiter does not <em>actually</em> clip all peaks completely, since the envelope for a single peak will have decayed a bit before the target gain will have reached it. Thus, the output gain will actually be slightly higher than what would be necessary to limit the output to the threshold. Since the attack factor is supposed to be significantly smaller than the release factor, this does not matter much though.</p>

<p>Also, it would probably be more useful to define the factors $f_a$ and $f_r$ in terms of the time they take to reach their target and the threshold $t$ in dB FS.</p>

<h2>Implementing audio processing in Python</h2>

<p>A real-time audio processing framework using PyAudio would look like this:</p>

<p>(<code>callback</code> is a function that will be defined shortly)</p>

<pre><code><span class="code">    <span class="symbol">from</span> pyaudio <span class="symbol">import</span> PyAudio, paFloat32
    
    pa = PyAudio<span class="paren1">(<span class="code"></span>)</span>
    
    stream = pa.open<span class="paren1">(<span class="code">format = paFloat32,
                     channels = 1,
                     rate = 44100,
                     output = True,
                     frames_per_buffer = 1024,
                     stream_callback = callback</span>)</span>
    
    <span class="symbol">while</span> stream.is_active<span class="paren1">(<span class="code"></span>)</span>:
        sleep<span class="paren1">(<span class="code">0.1</span>)</span>
    
    stream.close<span class="paren1">(<span class="code"></span>)</span>
    pa.terminate<span class="paren1">(<span class="code"></span>)</span></span></code></pre>

<p>This will open a <code>stream</code>, which is a PyAudio construct that manages input and output to/from one sound device. In this case, it is configured to use <code>float</code> values, only open one channel, play audio at a sample rate of 44100 Hz, have that one channel be output only and call the function <code>callback</code> every 1024 samples.</p>

<p>Since the <code>callback</code> will be executed on a different thread, control flow will continue immediately after <code>pa.open()</code>. In order to analyze the resulting signal, the <code>while stream.is_active()</code> loop waits until the signal has been processed completely.</p>

<p>Every time the <code>callback</code> is called, it will have to return 1024 samples of audio data. Using the class <code>Limiter</code> above, a sample counter <code>counter</code> and an audio signal <code>signal</code>, this can be implemented like this:</p>

<pre><code><span class="code">    limiter = Limiter<span class="paren1">(<span class="code">attack_coeff, release_coeff, delay, dtype</span>)</span>
    
    <span class="special">def</span><span
class="keyword"> callback</span><span class="paren1">(<span class="code">in_data, frame_count, time_info, flag</span>)</span>:
        <span class="symbol">if</span> flag:
            <span class="symbol">print</span><span class="paren1">(<span class="code"><span class="string">"Playback Error: %i"</span> % flag</span>)</span>
        played_frames = counter
        counter += frame_count
        limiter.limit<span class="paren1">(<span class="code">signal<span class="paren2">[<span class="code">played_frames:counter</span>]</span>, threshold</span>)</span>
        <span class="symbol">return</span> signal<span class="paren1">[<span class="code">played_frames:counter</span>]</span>, paContinue</span></code></pre>

<p>The <code>paContinue</code> at the end is a flag signifying that the audio processing is not done yet and the <code>callback</code> wants to be called again. Returning <code>paComplete</code> or an insufficient number of samples instead would stop audio processing after the current block and thus invalidate <code>stream.is_active()</code> and resume control flow in the snippet above.</p>

<p>Now this will run the limiter and play back the result. Sadly however, Python is just a bit too slow to make this work reliably. Even with a long block size of 1024 samples, this will result in occasional hickups and discontinuities. (Which the <code>callback</code> will display in the <code>print(...)</code> statement).</p>

<h2>Speeding up execution using Cython</h2>

<p>The limiter defined above could be rewritten in C like this:</p>

<pre><code><span class="code">    <span class="comment">// this corresponds to the Python Limiter class.
</span>    <span class="symbol">typedef</span> <span class="symbol">struct</span> limiter_state_t <span class="paren1">{<span class="code">
        <span class="symbol">int</span> delay_index;
        <span class="symbol">int</span> delay_length;
        <span class="symbol">float</span> envelope;
        <span class="symbol">float</span> current_gain;
        <span class="symbol">float</span> attack_coeff;
        <span class="symbol">float</span> release_coeff;
    </span>}</span> limiter_state;
    
    <span class="special">#define MAX(x,y) ((x)&gt;(y)?(x):(y))
</span>    
    <span class="comment">// this corresponds to the Python __init__ function.
</span>    limiter_state init_limiter<span class="paren1">(<span class="code"><span class="symbol">float</span> attack_coeff, <span class="symbol">float</span> release_coeff, <span class="symbol">int</span> delay_len</span>)</span> <span class="paren1">{<span class="code">
        limiter_state state;
        state.attack_coeff = attack_coeff;
        state.release_coeff = release_coeff;
        state.delay_index = 0;
        state.envelope = 0;
        state.current_gain = 1;
        state.delay_length = delay_len;
        <span class="symbol">return</span> state;
    </span>}</span>
    
    <span class="symbol">void</span> limit<span class="paren1">(<span class="code"><span class="symbol">float</span> *signal, <span class="symbol">int</span> block_length, <span class="symbol">float</span> threshold,
               <span class="symbol">float</span> *delay_line, limiter_state *state</span>)</span> <span class="paren1">{<span class="code">
        <span class="symbol">for</span><span class="paren2">(<span class="code"><span class="symbol">int</span> i=0; i&lt;block_length; i++</span>)</span> <span class="paren2">{<span class="code">
            delay_line<span class="paren3">[<span class="code">state-&gt;delay_index</span>]</span> = signal<span class="paren3">[<span class="code">i</span>]</span>;
            state-&gt;delay_index = <span class="paren3">(<span class="code">state-&gt;delay_index + 1</span>)</span> % state-&gt;delay_length;
    
            <span class="comment">// calculate an envelope of the signal
</span>            state-&gt;envelope *= state-&gt;release_coeff;
            state-&gt;envelope = MAX<span class="paren3">(<span class="code">fabs<span class="paren4">(<span class="code">signal<span class="paren5">[<span class="code">i</span>]</span></span>)</span>, state-&gt;envelope</span>)</span>;
    
            <span class="comment">// have current_gain go towards a desired limiter target_gain
</span>            <span class="symbol">float</span> target_gain;
            <span class="symbol">if</span> <span class="paren3">(<span class="code">state-&gt;envelope &gt; threshold</span>)</span>
                target_gain = <span class="paren3">(<span class="code">1+threshold-state-&gt;envelope</span>)</span>;
            <span class="symbol">else</span>
                target_gain = 1.0;
            state-&gt;current_gain = state-&gt;current_gain*state-&gt;attack_coeff +
                target_gain*<span class="paren3">(<span class="code">1-state-&gt;attack_coeff</span>)</span>;
    
            <span class="comment">// limit the delayed signal
</span>            signal<span class="paren3">[<span class="code">i</span>]</span> = delay_line<span class="paren3">[<span class="code">state-&gt;delay_index</span>]</span> * state-&gt;current_gain;
        </span>}</span>
    </span>}</span></span></code></pre>

<p>In contrast to the Python version, the delay line will be passed to the <code>limit</code> function. This is advantageous because now all audio buffers can be managed by Python instead of manually allocating and deallocating them in C.</p>

<p>Now in order to plug this code into Python I will use Cython. First of all, a &quot;Cython header&quot; file has to be created that declares all exported types and functions to Cython:</p>

<pre><code><span class="code">    cdef extern <span class="symbol">from</span> <span class="string">"limiter.h"</span>:
        ctypedef struct limiter_state:
            int delay_index
            int delay_length
            float envelope
            float current_gain
            float attack_coeff
            float release_coeff
    
        limiter_state init_limiter<span class="paren1">(<span class="code">float attack_factor, float release_factor, int delay_len</span>)</span>
        void limit<span class="paren1">(<span class="code">float *signal, int block_length, float threshold,
                   float *delay_line, limiter_state *state</span>)</span></span></code></pre>

<p>This is very similar to the C header file of the limiter:</p>

<pre><code><span class="code">    <span class="symbol">typedef</span> <span class="symbol">struct</span> limiter_state_t <span class="paren1">{<span class="code">
        <span class="symbol">int</span> delay_index;
        <span class="symbol">int</span> delay_length;
        <span class="symbol">float</span> envelope;
        <span class="symbol">float</span> current_gain;
        <span class="symbol">float</span> attack_coeff;
        <span class="symbol">float</span> release_coeff;
    </span>}</span> limiter_state;
    
    limiter_state init_limiter<span class="paren1">(<span class="code"><span class="symbol">float</span> attack_factor, <span class="symbol">float</span> release_factor, <span class="symbol">int</span> delay_len</span>)</span>;
    <span class="symbol">void</span> limit<span class="paren1">(<span class="code"><span class="symbol">float</span> *signal, <span class="symbol">int</span> block_length, <span class="symbol">float</span> threshold,
               <span class="symbol">float</span> *delay_line, limiter_state *state</span>)</span>;</span></code></pre>

<p>With that squared away, the C functions are accessible for Cython. Now, we only need a small Python wrapper around this code so it becomes usable from Python:</p>

<pre><code><span class="code">    <span class="symbol">import</span> numpy as np
    cimport numpy as np
    cimport limiter
    
    DTYPE = np.float32
    ctypedef np.float32_t DTYPE_t
    
    cdef <span class="special">class</span><span
class="keyword"> Limiter</span>:
        cdef limiter.limiter_state state
        cdef np.ndarray delay_line
        <span class="special">def</span><span
class="keyword"> __init__</span><span class="paren1">(<span class="code">self, float attack_coeff, float release_coeff,
                     int delay_length</span>)</span>:
            self.state = limiter.init_limiter<span class="paren1">(<span class="code">attack_coeff, release_coeff, delay_length</span>)</span>
            self.delay_line = np.zeros<span class="paren1">(<span class="code">delay_length, dtype=DTYPE</span>)</span>
    
        <span class="special">def</span><span
class="keyword"> limit</span><span class="paren1">(<span class="code">self, np.ndarray<span class="paren2">[<span class="code">DTYPE_t,ndim=1</span>]</span> signal, float threshold</span>)</span>:
            limiter.limit<span class="paren1">(<span class="code">&lt;float*&gt;np.PyArray_DATA<span class="paren2">(<span class="code">signal</span>)</span>,
                       &lt;int&gt;len<span class="paren2">(<span class="code">signal</span>)</span>, threshold,
                       &lt;float*&gt;np.PyArray_DATA<span class="paren2">(<span class="code">self.delay_line</span>)</span>,
                       &lt;limiter.limiter_state*&gt;&amp;self.state</span>)</span></span></code></pre>

<p>The first two lines set this file up to access Numpy arrays both from the Python domain and the C domain, thus bridging the gap. The <code>cimport limiter</code> imports the C functions and types from above. The <code>DTYPE</code> stuff is advertising the Numpy <code>float32</code> type to C.</p>

<p>The class is defined using <code>cdef</code> as a C data structure for speed. Also, Cython would naturally translate every C struct into a Python dict and vice versa, but we need to pass the struct to <code>limit</code> <em>and</em> have <code>limit</code> modify it. Thus, <code>cdef limiter.limiter_state state</code> makes Cython treat it as a C struct only. Finally, the <code>np.PyArray_DATA()</code> expressions expose the C arrays underlying the Numpy vectors. This is really handy since we don't have to copy any data around in order to modify the vectors from C.</p>

<p>As can be seen, the Cython implementation behaves nearly identically to the initial Python implementation (except for passing the <code>dtype</code> to the constructor) and can be used as a plug-in replacement (with the aforementioned caveat).</p>

<p>Finally, we need to build the whole contraption. The easiest way to do this is to use a setup file like this:</p>

<pre><code><span class="code">    <span class="symbol">from</span> distutils.core <span class="symbol">import</span> setup
    <span class="symbol">from</span> distutils.extension <span class="symbol">import</span> Extension
    <span class="symbol">from</span> Cython.Distutils <span class="symbol">import</span> build_ext
    <span class="symbol">from</span> numpy <span class="symbol">import</span> get_include
    
    ext_modules = <span class="paren1">[<span class="code">Extension<span class="paren2">(<span class="code"><span class="string">"cython_limiter"</span>,
                             sources=<span class="paren3">[<span class="code"><span class="string">"cython_limiter.pyx"</span>,
                                      <span class="string">"limiter.c"</span></span>]</span>,
                             include_dirs=<span class="paren3">[<span class="code"><span class="string">'.'</span>, get_include<span class="paren4">(<span class="code"></span>)</span></span>]</span></span>)</span></span>]</span>
    
    setup<span class="paren1">(<span class="code">
        name = <span class="string">"cython_limiter"</span>,
        cmdclass = <span class="paren2">{<span class="code"><span class="string">'build_ext'</span>: build_ext</span>}</span>,
        ext_modules = ext_modules
        </span>)</span></span></code></pre>

<p>With that saved as <em>setup.py</em>, <code>python setup.py build_ext --inplace</code> will convert the Cython code to C, and then compile both the converted Cython code and C code into a binary Python module.</p>

<h2>Conclusion</h2>

<p>In this article, I developed a simple limiter and how to implement it in both C and Python. Then, I showed how to use the C implementation from Python. Where the Python implementation is struggling to keep a steady frame rate going even at large block sizes, the Cython version runs smoothly down to 2-4 samples per block on a 2 Ghz Core i7. Thus, real-time audio processing is clearly feasable using Python, Cython, Numpy and PyAudio.</p>

<p>You can find all the source code in this article at https://github.com/bastibe/simple-cython-limiter</p>

<h2>Disclaimer</h2>

<ol>
<li>I invented this limiter myself. I could invent a better sounding limiter, but this article is more about how to combine Python, Numpy, PyAudio and Cython for real-time signal processing than about limiter design.</li>
<li>I recently worked on something similar at my day job. They agreed that I could write about it so long as I don't divulge any company secrets. This limiter is not a descendant of any code I worked on.</li>
<li>Whoever wants to use any piece of code here, feel free to do so. I am hereby placing it in the public domain. Feel free to contact me if you have questions.</li>
</ol>
</div> <hr> </div> <div id="relative-nav">   </div> <div id="tagsoup"> <p>This blog covers <a href="http://bastibe.de/testing//tag/Cython.html">Cython</a>, <a href="http://bastibe.de/testing//tag/Numpy.html">Numpy</a>, <a href="http://bastibe.de/testing//tag/PyAudio.html">PyAudio</a>, <a href="http://bastibe.de/testing//tag/Python.html">Python</a>, <a href="http://bastibe.de/testing//tag/apple-tv.html">apple-tv</a>, <a href="http://bastibe.de/testing//tag/computers.html">computers</a>, <a href="http://bastibe.de/testing//tag/error.html">error</a>, <a href="http://bastibe.de/testing//tag/matlab.html">matlab</a>, <a href="http://bastibe.de/testing//tag/philosophy.html">philosophy</a>, <a href="http://bastibe.de/testing//tag/programming.html">programming</a>, <a href="http://bastibe.de/testing//tag/python.html">python</a> </div> <div id="monthsoup"> <p>View posts from <a href="http://bastibe.de/testing//date/2013-01.html">2013-01</a>, <a href="http://bastibe.de/testing//date/2012-11.html">2012-11</a>, <a href="http://bastibe.de/testing//date/2012-10.html">2012-10</a> </div> </div>  <div class="fineprint"> <hr> Unless otherwise credited all material <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"> <img alt="Creative Commons License" style="border-width:0" src="http://bastibe.de/testing//css/cc-by-sa.png" /> </a> by Bastian Bechtold <img align="right" src="http://bastibe.de/testing//css/logo_small.jpg" /> </div> </body> </html>
