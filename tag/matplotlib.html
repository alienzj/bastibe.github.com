<!doctype html>
<html> <head> <title>Bastis Scratchpad on the Internet</title> <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" /> <meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"> <link href= "http://bastibe.de/css/style.css" rel="stylesheet" type="text/css" /> <link rel="alternate" href="http://bastibe.de/rss.xml" type="application/rss+xml" /> <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: { inlineMath: [["$","$"]] }});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </head> <body> <div class="header"> <a href="http://bastibe.de">Bastis Scratchpad on the Internet</a> <div class="sitelinks"> <a href="http://alpha.app.net/bastibe">alpha.app.net</a>  | <a href="http://github.com/bastibe">Github</a>  </div> </div> <div id="content"> <div class="article-meta"> <a class="article-title" href="http://bastibe.de/posts/Speeding-up-Matplotlib.html">Speeding up Matplotlib</a> <div class="date"> posted on 2013-05-30 10:50</div> <div class="article">

<p>For the record, <a href="http://matplotlib.org" >Matplotlib</a> is awesome! Its output looks amazing, it is extremely configurable and very easy to use. What more could you want?</p>

<p>Well... speed. If there is one thing I could criticize about Matplotlib, it is its relative slowness. To measure that, lets make a very simple line plot and draw some random numbers as quickly as possible:</p>

<pre><code><span class="code"><span class="symbol">import</span> matplotlib.pyplot as plt
<span class="symbol">import</span> numpy as np
<span class="symbol">import</span> time

fig, ax = plt.subplots<span class="paren1">(<span class="code"></span>)</span>

tstart = time.time<span class="paren1">(<span class="code"></span>)</span>
num_plots = 0
<span class="symbol">while</span> time.time<span class="paren1">(<span class="code"></span>)</span>-tstart &lt; 1:
    ax.clear<span class="paren1">(<span class="code"></span>)</span>
    ax.plot<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>
    plt.pause<span class="paren1">(<span class="code">0.001</span>)</span>
    num_plots += 1
<span class="symbol">print</span><span class="paren1">(<span class="code">num_plots</span>)</span></span></code></pre>

<p>On my machine, I get about 11 plots per second. I am using <code>pause()</code> here to update the plot without blocking. The correct way to do this is to use <code>draw()</code> instead, but due to a bug in the Qt4Agg backend, you can't use it there. If you are not using the Qt4Agg backend, <code>draw()</code> is supposedly the correct choice.</p>

<p>For a single plot, ten plots per second is not terrible. But then, this is really the simplest case possible, so ten frames per second in the simplest case probably means bad things for not so simple cases.</p>

<p>One thing that really takes time here is creating all the axes and text labels over and over again. So let's not do that.</p>

<p>Instead of calling <code>clear()</code> and then <code>plot()</code>, thus effectively deleting everything about the plot, then re-creating it for every frame, we can keep an existing plot and only modify its data:</p>

<pre><code><span class="code">fig, ax = plt.subplots<span class="paren1">(<span class="code"></span>)</span>
line, = ax.plot<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>

tstart = time.time<span class="paren1">(<span class="code"></span>)</span>
num_plots = 0
<span class="symbol">while</span> time.time<span class="paren1">(<span class="code"></span>)</span>-tstart &lt; 1:
    line.set_ydata<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>
    plt.pause<span class="paren1">(<span class="code">0.001</span>)</span>
    num_plots += 1
<span class="symbol">print</span><span class="paren1">(<span class="code">num_plots</span>)</span></span></code></pre>

<p>which yields about 26 plots per second. Not bad for a simple change like this. The downside is that the axes are not re-scaled any longer when the data changes. Thus, they won't change their limits based on the data any more.</p>

<p>Profiling this yields some interesting results:</p>

<pre><code>ncalls  tottime  percall  cumtime  percall filename:lineno(function)
15      0.167    0.011    0.167    0.011 {built-in method sleep}
</code></pre>

<p>The one function that uses the biggest chunk of runtime is <code>sleep()</code>, of all things. Clearly, this is not what we want. Delving deeper into the profiler shows that this is indeed happening in the call do <code>pause()</code>. Then again, I <em>was</em> wondering if using <em>pause</em> really was a great idea for performance...</p>

<p>As it turns out, <code>pause()</code> internally calls <code>fig.canvas.draw()</code>, then <code>plt.show()</code>, then <code>fig.canvas.start_event_loop()</code>. The default implementation of <code>fig.canvas.start_event_loop()</code> then calls <code>fig.canvas.flush_events()</code>, then sleeps for the requested time. To add insult to injury, it even insists on sleeping at least one hundredth of a second, which actually explains the profiler output of 0.167 seconds of <code>sleep()</code> for 15 calls very well.</p>

<p>Putting this all together now yields:</p>

<pre><code><span class="code">fig, ax = plt.subplots<span class="paren1">(<span class="code"></span>)</span>
line, = ax.plot<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>

tstart = time.time<span class="paren1">(<span class="code"></span>)</span>
num_plots = 0
<span class="symbol">while</span> time.time<span class="paren1">(<span class="code"></span>)</span>-tstart &lt; 1:
    line.set_ydata<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>
    fig.canvas.draw<span class="paren1">(<span class="code"></span>)</span>
    fig.canvas.flush_events<span class="paren1">(<span class="code"></span>)</span>
    num_plots += 1
<span class="symbol">print</span><span class="paren1">(<span class="code">num_plots</span>)</span></span></code></pre>

<p>which now plots about 40 frames per second. Note that the call to <code>show()</code> mentioned earlier can be omitted since the figure is already on screen. <code>flush_events()</code> just runs the Qt event loop, so there is probably nothing to optimize there.</p>

<p>The only thing left to optimize now is thus <code>fig.canvas.draw()</code>. What this really is doing is drawing all the artists contained in the <code>ax</code>. Those artists can be accessed using <code>ax.get_children()</code>. For a simple plot like this, the artists are:</p>

<ul>
<li>the background <code>ax.patch</code></li>
<li>the line, as returned from the <code>plot()</code> function</li>
<li>the spines <code>ax.spines</code></li>
<li>the axes <code>ax.xaxis</code> and <code>ax.yaxis</code></li>
</ul>

<p>What we can do here is to selectively draw only the parts that are actually changing. That is, at least the background and the line. To only redraw these, the code now looks like this:</p>

<pre><code><span class="code">fig, ax = plt.subplots<span class="paren1">(<span class="code"></span>)</span>
line, = ax.plot<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>
plt.show<span class="paren1">(<span class="code">block=False</span>)</span>

tstart = time.time<span class="paren1">(<span class="code"></span>)</span>
num_plots = 0
<span class="symbol">while</span> time.time<span class="paren1">(<span class="code"></span>)</span>-tstart &lt; 5:
    line.set_ydata<span class="paren1">(<span class="code">np.random.randn<span class="paren2">(<span class="code">100</span>)</span></span>)</span>
    ax.draw_artist<span class="paren1">(<span class="code">ax.patch</span>)</span>
    ax.draw_artist<span class="paren1">(<span class="code">line</span>)</span>
    fig.canvas.update<span class="paren1">(<span class="code"></span>)</span>
    fig.canvas.flush_events<span class="paren1">(<span class="code"></span>)</span>
    num_plots += 1
<span class="symbol">print</span><span class="paren1">(<span class="code">num_plots/5</span>)</span></span></code></pre>

<p>Note that you have to add <code>fig.canvas.update()</code> to copy the newly rendered lines to the drawing backend.</p>

<p>This now plots about 500 frames per second. Five hundred times per second! Frankly, this is quite amazing!</p>

<p>Note that since we are only redrawing the background and the line, some detail in the axes will be overwritten. To also draw the spines, use <code>for spine in ax.spines.values(): ax.draw_artist(spine)</code>. To draw the axes, use <code>ax.draw_artist(ax.xaxis)</code> and <code>ax.draw_artist(ax.yaxis)</code>. If you draw all of them, you get roughly the same performance as <code>fig.canvas.draw()</code>. The axes in particular are quite expensive.</p>

<p>There is also <a href="http://stackoverflow.com/a/8956211/1034" >a way</a> of drawing the complete figure once and copying the complete but empty background, then reinstating that and only plotting a new line on top of it. This is equally fast as the code above without any visual artifacts, but breaks if you resize the plot.</p>

<p>In conclusion, I am quite impressed with the flexibility of Matplotlib. Matplotlib by default values quality over performance. But if you really need the performance at some point, it is flexible and hackable enough to let you tweak it to your hearts content. Really, an amazing piece of technology!</p>

<p><strong>EDIT</strong>: As it turns out, <code>fig.canvas.blit(ax.bbox)</code> is a bad idea since it leaks memory like crazy. What you should use instead is <code>fig.canvas.update()</code>, which is equally fast but does not leak memory.</p>
</div> <hr> </div><div class="article-meta"> <a class="article-title" href="http://bastibe.de/posts/Compiling-Scipy-and-Matplotlib-using-pip-on-Lion.html">Compiling Scipy and Matplotlib using pip on Lion</a> <div class="date"> posted on 2011-08-01 12:40</div> <div class="article">

<p>So I upgraded to Lion. Predictably, some things went wrong. This time, the main thing that bit me was that for some reason, <code>pip</code> stopped working. After a bit of messing around with <code>brew</code>, <code>pip</code> and <code>easy_install</code>, I found out it was almost entirely my own fault. I messed up my <code>PATH</code>.</p>

<p>In the meantime, I had uninstalled all of <code>brew</code>'s Python, so I had to reinstall. For me, that entails Python, Numpy, Scipy and Matplotlib. Only this time, Scipy would not build. Some obscure error in some <code>veclib_cabi_c.c</code> would report errors. A quick <a href="http://mail.scipy.org/pipermail/scipy-user/2009-June/021383.html" >round of googling</a> reveals:</p>

<p>In order to get Scipy to compile, you need to insert <code>#include &lt;complex.h&gt;</code> in</p>

<pre><code>./scipy/lib/blas/fblaswrap_veclib_c.c.src
./scipy/linalg/src/fblaswrap_veclib_c.c
./scipy/sparse/linalg/eigen/arpack/ARPACK/FWRAPPERS/veclib_cabi_c.c
</code></pre>

<p>That done, Scipy compiles perfectly fine.</p>

<p>But, that is not enough yet. As <a href="http://jholewinski.wordpress.com/2011/07/21/installing-matplotlib-on-os-x-10-7-with-homebrew/" >this blogpost</a> outlines, Matplotlib is not currently compatible with <code>libpng</code> 1.5, which ships with Lion. Fortunately, this is already fixed in the most recent source on the Matplotlib repo, so you just have to checkout that:</p>

<pre><code>pip install -e git+https://github.com/matplotlib/matplotlib.git#egg=matplotlib
</code></pre>

<p>By doing that, Matplotlib should install just fine.</p>

<p>Seriously though, these PyPi repos are in a very sorry state. Every time I install one of these packages, I have to jump through hoops and spend hours debugging packages that really should work right out of the box. After all, <code>brew</code>, <code>rvm</code> and <code>gem</code> can do it just fine. Why is <code>pip</code> such a horrible mess?</p>
</div> <hr> </div><div class="article-meta"> <a class="article-title" href="http://bastibe.de/posts/Installing-Pygame-using-Homebrew.html">Installing Pygame using Homebrew</a> <div class="date"> posted on 2011-03-04 14:16</div> <div class="article">

<p>So I want to do audio development on the Mac without using Matlab. An alternative to Matlab is Python, or rather, <a href="http://www.daskrachen.com/2011/02/installing-pythonnumpyscipymatplotlib.html" >Numpy, Scipy and Matplotlib</a>. They are awesome for working with audio data. What they don't do however is playing back audio. There are several packages out there that would afford audio playback. If you are serious about this though, you not only want audio playback, you want asynchronous audio playback. That is, you want to send some audio data to the sound card and continue with your program without waiting for the audio to finish playing. This allows continuous audio playback of computer-generated sound.</p>

<p><a href="http://www.pygame.org/news.html" >Pygame</a> is one package that allows this. (I will submit a patch to <a href="http://people.csail.mit.edu/hubert/pyaudio/" >Pyaudio</a> soon that will enable it there, too). There are pre-built binaries on the Pygame website that you can install easily. But then there would be no easy way to uninstall them, so what I would rather want is to install Pygame using package managers that allow easy updating and uninstallation. My tool of choice on the Mac is of course <a href="https://github.com/mxcl/homebrew/" >Homebrew</a>.</p>

<p>Note that although I am mostly interested in audio playback, this post will detail the installation of all modules of Pygame, not just <code>pygame.mixer</code>.</p>

<p>Homebrew won't install Pygame, but it will install all the prerequisites for Pygame. So, let's do that.</p>

<pre><code>brew install sdl, sdl_mixer, sdl_ttf, libpng, jpeg, sdl_image, portmidi
</code></pre>

<p>This will install most packages for you. Note that <code>libpng</code> is also available as a system library, so it is installed <code>keg_only</code>, that is, without linking it in your path. We will need to compile against it though, so the next step is</p>

<pre><code>brew link libpng
</code></pre>

<p>Now there is still one package missing, <code>smpeg</code>. Sadly, <code>smpeg</code> does not install its headers, so you can't compile against it. To fix that, type</p>

<pre><code>brew edit smpeg
</code></pre>

<p>and add the following line just above the two end at the end of the file</p>

<pre><code>include.install Dir[&quot;*.h&quot;]
</code></pre>

<p>Then save the file. (I submitted a bug to have this fixed, so you might not need to do this when you read this). Now you can install <code>smpeg</code> with the usual</p>

<pre><code>brew install smpeg
</code></pre>

<p>and you will get the headers, too. Isn't Homebrew great?</p>

<p>Now that all the prerequisites are met, lets look at Pygame itself. This is rather more difficult, as it will not build properly against Homebrew libraries on its own. First, download the source package of Pygame from the <a href="http://www.pygame.org/download.shtml" >official website</a>. Unpack it to some directory.</p>

<p>Now open a terminal and navigate to that directory. Me, I like <a href="http://iterm.sourceforge.net/" >iTerm</a>, but Terminal.app will do just fine, too. In there, run <code>python config.py</code> to create an initial setup file.</p>

<p>At this point, the setup file is mostly useless since <code>config.py</code> failed to find any homebrew-installed library. It is also strangely garbled, so there is some manual labor to do. Open the file <code>Setup</code> (no extension) in your favourite text editor. After the first comment block, you will see a line that looks like this</p>

<pre><code>SDL = -I/NEED_INC_PATH_FIX -L/NEED_LIB_PATH_FIX -lSDL
</code></pre>

<p>Obviously, this is lacking the paths to the SDL library. If you installed Homebrew to its default directory, this will be in <code>/usr/local…</code>. Hence, change this line to</p>

<pre><code>SDL = -I/usr/local/include/SDL -L/usr/local/lib -lSDL
</code></pre>

<p>The next lines are strangely garbled. They say, for example</p>

<pre><code>FONT = -lS -lD -lL -l_ -lt -lt -lf
</code></pre>

<p>Where they actually should say</p>

<pre><code>FONT = -lSDL_ttf
</code></pre>

<p>Instead of having one <code>-l</code> and then the library name <code>SDL_ttf</code>, they put <code>-l</code> in front of every single letter of the name. This is strange, and certainly wrong. So, correct it for <code>FONT</code>, <code>IMAGE</code>, <code>MIXER</code> and <code>SMPEG</code>.</p>

<p>Note that I did not tell you to do this for <code>PORTTIME</code>, too. Actually, <code>PORTTIME</code> is already correctly linked in <code>PORTMIDI</code>, so you don't need that at all any more. Just delete or comment the <code>PORTTIME</code> line.</p>

<p>Now that all the dependencies are corrected, lets enable the features. A few lines further down, there will be a block of lines, where most lines begin with a <code>#</code> except for the ones beginning with <code>_numericsurfarray…</code> and <code>_camera…</code>, These are the different features of Pygame: The ones with the <code>#</code> are disabled, the other two are enabled.</p>

<p>With all the stuff we installed earlier, you can now enable all features (remove the <code>#</code> in front of <code>imageext…</code>, <code>font…</code>, <code>mixer…</code>, <code>mixer_music…</code>, <code>_minericsndarray…</code>, <code>movie…</code>, <code>scrap…</code> and <code>pypm…</code>).</p>

<p>Remember we disabled <code>PORTTIME</code> a while ago? Right, so we have to remove that dependency: In the line starting with <code>pypm…</code>, delete the part that says <code>$(PORTTIME)</code>. Great. That was easy, right? Now save that file and go back to the Terminal.</p>

<p>We are now going to compile and install Pygame. The nice thing is, even though we are installing it manually, it will go in the right directories and it will be registered with <code>pip</code> or <code>easy_install</code>, so you can just invoke them if you want to uninstall it later by typing <code>pip uninstall pygame</code>. This is something I love about Python!</p>

<p>Alright, now without further ado, install Pygame by typing</p>

<pre><code>python setup.py install
</code></pre>

<p>Great! That's it! Everything should work now!</p>
</div> <hr> </div><div class="article-meta"> <a class="article-title" href="http://bastibe.de/posts/Installing-PythonNumpyScipyMatplotlib-on-OSX.html">Installing Python/Numpy/Scipy/Matplotlib on OSX</a> <div class="date"> posted on 2011-02-03 16:23</div> <div class="article">

<p>For numerical analysis and signal processing prototyping, you would use <a href="http://www.mathworks.com/products/matlab/" >Matlab</a>. However, Matlab has some downsides that might make it unsuitable for your project. It might be too expensive. You might be a snobbish programmer that can't stand less-than-elegant programming languages. I certainly am.</p>

<p>So, you look for alternatives. You could take <a href="http://www.gnu.org/software/octave/" >Octave</a>, which is free, but that would not solve that ugly-code issue. You could take any scripting language you fancy, but Ruby, Perl and Python are too slow to do serious number crunching.</p>

<p>Then, you stumble upon that Python package called <a href="http://numpy.scipy.org/" >Numpy</a>, which seems to be nearly as fast as Matlab when it comes to matrix processing and linear algebra. You then discover <a href="http://www.scipy.org/" >SciPy</a>, which would add all that signal processing prowess of Matlab (do quick transformations, random numbers, statistics) to your toolbox. Last but not least, you need plotting. That would be <a href="http://matplotlib.sourceforge.net/" >Matplotlib</a> then, which provides quick plotting facilities in Python.</p>

<p>And the best thing is, these three systems work really well together. They seem to be the perfect replacement for Matlab that could even be superiour to it in many regards.</p>

<p>Next up, you need to install all that stuff. If you are like me, you naturally want to do all that on a Mac. Also, you kind of dislike all these installer-thingies, which install stuff to unknown places and are nigh impossible to uninstall or update cleanly. Even though, you could of course just go to the individual websites, download Python, Numpy, SciPy and Matplotlib, run them installers, and be done. You would save yourself a lot of trouble that way.</p>

<p>But since you allegedly are like me, you instead fire up <a href="http://mxcl.github.com/homebrew" ><code>brew</code></a> and try to install all that stuff using that. Again, you could use <a href="http://www.macports.org/" >MacPorts</a> or <a href="http://www.finkproject.org/" >Fink</a> instead, but you probably had some bad experiences with them and you generally love the hackishness of Homebrew, so this is your natural first try.</p>

<p>So you set about this, you believe in packet managers and trust them to take care of every obstacle that might be lying in your way. First of all, install the latest developer tools from <a href="http://developer.apple.com/" >developer.apple.com</a>. You might need to register (for free) to get them. Also, you need to install <a href="http://mxcl.github.com/homebrew" >Homebrew</a>.</p>

<p>To cut this short, here is what you need to get that Python running:</p>

<pre><code>brew install python
</code></pre>

<p>This one should be obvious. At the time of writing, it will install Python 2.7.1. You could take Python 3, but matplotlib is not compatible to it, so you kind of have to stick with 2.7.1 instead.</p>

<p>You also need to put <code>/usr/local/bin</code> and <code>/usr/local/sbin</code> in the beginning of your path to make sure the new Python gets loaded instead of the pre-installed one. You do that by writing</p>

<pre><code>export PATH=/usr/local/bin:/usr/local/sbin:$PATH
</code></pre>

<p>in your <code>~/.bash_profile</code>. (Create it if its not there--it is just a simple text file).</p>

<p>Now, if you type <code>python --version</code>, you should get <code>Python 2.7.1</code> as a response.</p>

<p>Alright, next up, install the python package manager:</p>

<pre><code>brew install distribute
brew install pip
</code></pre>

<p>This will come preconfigured for your newly installed Python. In an ideal world, this should be all. The world being as it is, the pip package of Matplotlib is severely broken and has one other unstated dependency:</p>

<pre><code>brew install pkg-config
</code></pre>

<p>Also, SciPy is using some FORTRAN sources, so you need a fortran compiler:</p>

<pre><code>brew install gfortran
</code></pre>

<p>Alright. That was enough. Now on to pip. With all these dependencies cleared, pip should be able to download Numpy and Scipy without trouble:</p>

<pre><code>pip install numpy
pip install scipy
</code></pre>

<p>Matplotlib, on the other hand, is more difficult to install. You see, pip is looking at the Python package repository <a href="http://pypi.python.org/" >PyPi</a> for each package. PyPi then provides a URL. Pip then scans that website for links to suitable package files. But, <a href="http://sourceforge.net/" >Sourceforge</a> changed its links a while ago, so pip gets confused and will download an outdated version. Sourceforge says, its new links are way better and no way we will change them back; Pip says, well, if Sourceforge can't provide proper links, that's not our problem. Oh My. Silly children.</p>

<p>So we have to do this manually:</p>

<pre><code>pip install -f http://sourceforge.net/projects/matplotlib/files/matplotlib/matplotlib-1.0.1/matplotlib-1.0.1.tar.gz matplotlib
</code></pre>

<p>That URL comes straight from Sourceforge. Look for the latest version of Matplotlib, search for the download link to the source distribution (<code>*.tar.gz</code>), copy that link and strip any trailing '/download'.</p>

<p>UPDATE:</p>

<p>It seems the matplotlib package was updated in the meantime, so you can just run <code>pip install matplotlib</code> now.</p>

<p>This should now download and install matplotlib.</p>

<p>Thank you for reading.</p>
</div> <hr> </div> <div id="relative-nav">   </div> <div id="tagsoup"> <p>This blog covers <a href="http://bastibe.de/tag/apple.html">apple</a>, <a href="http://bastibe.de/tag/apple-tv.html">apple-tv</a>, <a href="http://bastibe.de/tag/blog.html">blog</a>, <a href="http://bastibe.de/tag/codehilite.html">codehilite</a>, <a href="http://bastibe.de/tag/compiling.html">compiling</a>, <a href="http://bastibe.de/tag/computers.html">computers</a>, <a href="http://bastibe.de/tag/cython.html">cython</a>, <a href="http://bastibe.de/tag/emacs.html">emacs</a>, <a href="http://bastibe.de/tag/error.html">error</a>, <a href="http://bastibe.de/tag/file-system.html">file-system</a>, <a href="http://bastibe.de/tag/gaming.html">gaming</a>, <a href="http://bastibe.de/tag/gem.html">gem</a>, <a href="http://bastibe.de/tag/homebrew.html">homebrew</a>, <a href="http://bastibe.de/tag/matlab.html">matlab</a>, <a href="http://bastibe.de/tag/matplitlib.html">matplitlib</a>, <a href="http://bastibe.de/tag/matplotlib.html">matplotlib</a>, <a href="http://bastibe.de/tag/mountainlion.html">mountainlion</a>, <a href="http://bastibe.de/tag/numpy.html">numpy</a>, <a href="http://bastibe.de/tag/open-source.html">open-source</a>, <a href="http://bastibe.de/tag/pelican.html">pelican</a>, <a href="http://bastibe.de/tag/philosophy.html">philosophy</a>, <a href="http://bastibe.de/tag/pip.html">pip</a>, <a href="http://bastibe.de/tag/programming.html">programming</a>, <a href="http://bastibe.de/tag/pyaudio.html">pyaudio</a>, <a href="http://bastibe.de/tag/pygame.html">pygame</a>, <a href="http://bastibe.de/tag/pygments.html">pygments</a>, <a href="http://bastibe.de/tag/python.html">python</a>, <a href="http://bastibe.de/tag/raspberrypi.html">raspberrypi</a>, <a href="http://bastibe.de/tag/scheme.html">scheme</a>, <a href="http://bastibe.de/tag/scipy.html">scipy</a>, <a href="http://bastibe.de/tag/solarized.html">solarized</a>, <a href="http://bastibe.de/tag/sublime-text.html">sublime-text</a>, <a href="http://bastibe.de/tag/text-editor.html">text-editor</a>, <a href="http://bastibe.de/tag/ui.html">ui</a>, <a href="http://bastibe.de/tag/vim.html">vim</a> </div> <div id="monthsoup"> <p>View posts from <a href="http://bastibe.de/date/2013-05.html">2013-05</a>, <a href="http://bastibe.de/date/2013-01.html">2013-01</a>, <a href="http://bastibe.de/date/2012-11.html">2012-11</a>, <a href="http://bastibe.de/date/2012-10.html">2012-10</a>, <a href="http://bastibe.de/date/2012-09.html">2012-09</a>, <a href="http://bastibe.de/date/2012-08.html">2012-08</a>, <a href="http://bastibe.de/date/2012-07.html">2012-07</a>, <a href="http://bastibe.de/date/2012-02.html">2012-02</a>, <a href="http://bastibe.de/date/2011-12.html">2011-12</a>, <a href="http://bastibe.de/date/2011-10.html">2011-10</a>, <a href="http://bastibe.de/date/2011-09.html">2011-09</a>, <a href="http://bastibe.de/date/2011-08.html">2011-08</a>, <a href="http://bastibe.de/date/2011-03.html">2011-03</a>, <a href="http://bastibe.de/date/2011-02.html">2011-02</a>, <a href="http://bastibe.de/date/2010-07.html">2010-07</a>, <a href="http://bastibe.de/date/2009-04.html">2009-04</a>, <a href="http://bastibe.de/date/2009-03.html">2009-03</a> </div> </div>  <div class="fineprint"> <hr> Unless otherwise credited all material <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"> <img alt="Creative Commons License" style="border-width:0" src="http://bastibe.de/css/cc-by-sa.png" /> </a> by Bastian Bechtold <img align="right" src="http://bastibe.de/css/logo_small.jpg" /> </div> </body> </html>
