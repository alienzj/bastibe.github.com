<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="alternate"
      type="appliation/rss+xml"
      href="http://bastibe.de/rss.xml"
      title="RSS feed for http://bastibe.de/">
<title>Bastibe.de</title><meta  name="author" content="Bastian Bechtold" />
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> </script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="http://bastibe.de">Basti's Scratchpad on the Internet</a>
  <div class="sitelinks">
    <a href="https://twitter.com/paperflyer">Twitter</a> | <a href="http://github.com/bastibe">Github</a>
  </div>
</div></div>
<div id="content"><div class="post-date">20 Dec 2017</div><h1 class="post-title"><a href="http://bastibe.de/2017-12-20-books-of-2017.html">Books of 2017</a></h1>
<p>
In late 2016, I took a short ferry flight to a small island in the area, and rekindled my love for aviation. Shortly afterwards, I started training for a pilot's license, and reading about aviation. From a literary perspective, aviation exists in the perfect goldilocks time frame of being just old enough to be thoroughly romanticized, but young enough for first-hand reports and thorough documentation to be available. What is more, powered flight has provided human observers with an unprecedented view of our world and our struggles, and is often as philosophical as it is exhilarating.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Aviation Reading List</h2>
<div class="outline-text-2" id="text-1">
<p>
Out of a long list of fascinating books on aviation I have read over the last two years, my favorites are:
</p>


<div class="figure">
<p><img src="https://images.gr-assets.com/books/1348443108l/533779.jpg" alt="533779.jpg" style="float:left;margin:5px;margin-right:20px" width="150px" />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.goodreads.com/book/show/533779.Fate_Is_the_Hunter">Fate is the Hunter</a> by Ernest K. Gann, a gripping memoir of the early days of aviation. It has been only a little more than a hundred years since humans first took to the skies in Kitty Hawk in 1905, yet today aviation feels as mundane as horse-drawn carriages must have felt to the Wright Brothers. Gann lived through these early days, and tells his tales from a time when aviation was still young, dangerous, and perhaps more interesting. If you want to read more like this, <a href="https://www.goodreads.com/book/show/400492.Flight_of_Passage">Flight of Passage</a> by Rinker Buck, and <a href="https://www.goodreads.com/book/show/571406.The_Spirit_of_St_Louis">The Spirit of St. Louis</a> by Charles Lindbergh are easy recommendations as well.
</li>
</ul>


<div class="figure">
<p><img src="https://images.gr-assets.com/books/1503014062l/36060428.jpg" alt="36060428.jpg" style="float:left;margin:5px;margin-right:20px" width="150px" />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.goodreads.com/book/show/612456.Carrying_the_Fire">Carrying the Fire</a> by Michael Collins, one of the few first-hand accounts of an Apollo astronaut's voyage to the Moon. Most astronauts have published books later on, but most had them ghost-written, and none are as visceral and engaging as Michael Collins' journey on Apollo 8. It is humbling that Apollo's achievements have not been surpassed, despite our much more advanced technology and science. Other accounts worth reading are <a href="https://www.goodreads.com/book/show/271540.The_Last_Man_on_the_Moon">The Last Man on the Moon</a> by Gene Cernan on Apollo 17, and <a href="https://www.goodreads.com/book/show/2323178.How_Apollo_Flew_to_the_Moon?ac=1&from_search=true">How Apollo Flew to the Moon</a> by W. David Woods, for a more technical view.
</li>
</ul>


<div class="figure">
<p><img src="https://images.gr-assets.com/books/1458495570l/26210477.jpg" alt="26210477.jpg" style="float:left;margin:5px;margin-right:20px" width="150px" />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.goodreads.com/book/show/22926778-skyfaring">Skyfaring</a> by Mark Vanhoenacker is a more modern, and more philosophical account of how aviation has changed our perception of the world. If you yearn to fly like I do, then this book a balm for the soul. The almost spiritual feeling of cutting your bonds with the ground is what this book is about, despite being written in today's un-romantic days of routine commercial airliners. I love it dearly. A more grounded account of aviation's history is <a href="https://www.goodreads.com/book/show/1492469.Turbulent_Skies?from_search=true">Turbulent Skies</a> by T. A. Heppenheimer, and maybe <a href="https://www.goodreads.com/book/show/107298.Slide_Rule?from_search=true">Slide Rule</a> by Nevil Chute for some history on airships.
</li>
</ul>

<br>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Fiction Reading List</h2>
<div class="outline-text-2" id="text-2">
<p>
But as much as I love aviation, my first love is still Science Fiction. We live in strange times of unprecedented prosperity, and yet we are strangely unsatisfied, as if the future didn't turn out to be the utopia it was meant to be. Or is this just a reflection of ourselves, how we do not live up to the future we built?
</p>


<div class="figure">
<p><img src="https://images.gr-assets.com/books/1457598923l/29475447.jpg" alt="29475447.jpg" style="float:left;margin:5px;margin-right:20px" width="150px" />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.goodreads.com/series/170872-wayfarers">A Closed and Common Orbit</a> by Becky Chambers describes a more distant future, when space travel is as mundane as airliners are today, and humanity is just one of several alien species. Yet, with all its technological marvels, we still yearn for meaning and love, regardless of what strange world we live in. A Closed and Common Orbit is the second book in the series, and the first book I read. I think I prefer it in this order.
</li>
</ul>

<br><br>


<div class="figure">
<p><img src="https://images.gr-assets.com/books/1328341796l/8605343.jpg" alt="8605343.jpg" style="float:left;margin:5px;margin-right:20px" width="150px" />
</p>
</div>

<ul class="org-ul">
<li><a href="https://www.goodreads.com/series/50764-laundry-files">The Laundry Files</a> by Charles Stross are closer to home. Did you ever notice how computer programming is eerily similar to the arcane incantations we use to describe magic in fiction? Where is the difference between invoking a function that effects a robot, and invoking a magic spell that affects a demon? According to Charles Stross, this difference is really only playing with semantics, and we should be very careful with our incantations, lest the ghost in the machine really does have our demise in mind. I have not laughed this hard about a book in a long time, as when that weaponized PowerPoint turned people into zombies, or when that structured cabling project turned out to create an inadvertent summoning grid for an elder horror.
</li>
</ul>
</div>
</div>
<div class="post-date">20 Nov 2017</div><h1 class="post-title"><a href="http://bastibe.de/2017-11-20-pyenv.html">PyEnv is the new Conda</a></h1>
<p>
How to install Python? If your platform has a package manager, you might be tempted to use that to install Python. But I don't like that. That version is often outdated, and you risk messing with an integral part of your operating system. Instead, I like to install a separate Python in my home directory. I used to use <a href="https://conda.io/miniconda.html">Anaconda</a> (or <a href="http://winpython.github.io/">WinPython</a>, or <a href="https://www.enthought.com/product/enthought-python-distribution">EPD</a>) to do this. But now there is a better way: <a href="https://github.com/pyenv/pyenv">PyEnv</a>
</p>

<p>
The thing is: PyEnv installs (any version of) Python. That's all it does.
</p>

<p>
So why would I choose PyEnv over the more popular Anaconda? Because Anaconda is a Python distribution, a package manager, an environment manager, and a platform for paid packages. In the past, they once did <a href="https://stackoverflow.com/questions/38524856/anaconda-3-for-linux-has-no-ensurepip#39114277">break pip</a> because they wanted to promote conda instead. Some features of conda <a href="https://anaconda.org/">require a login</a>, some require a <a href="https://www.anaconda.com/enterprise/">paid subscription</a>. When you install packages through conda, you get binaries and source code from anaconda's servers, <i>not</i> the official packages from PyPi, which might or might not be up-to-date and feature-complete. For every package you install, you have to make a choice of using pip or conda, and the same goes for specifying your dependencies.
</p>

<p>
As an aside, many of these complaints are just as true for package-manager-provided Python packages (which often <a href="https://askubuntu.com/questions/879437/ensurepip-is-disabled-in-debian-ubuntu-for-the-system-python#897004">break pip</a>, too!). Just like Anaconda, package managers want to be the true and only source of packages, and don't like to interact with Python's own package manager.
</p>

<p>
In contrast, with PyEnv, you install a Python. This can be a version of CPython, PyPy, IronPython, Jython, Pyston, stackless, miniconda, or even Anaconda. It downloads the sources from the official repos, and compiles them on your machine <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>. Plus, it provides an easy and transparent way of switching between installed versions (including any system-installed versions). After that, you use Python's own venv and pip.
</p>

<p>
I find this process much simpler, and easier to manage, because it relies on small, orthogonal tools (pyenv, venv, pip) instead of one integrated conda that kind of does everything. I also like to use these official tools and packages instead of conda's parallel universe of mostly-open, mostly-free, mostly-standard replacements.
</p>

<p>
Mind you, conda solved real problems back in the day (binary package distributions, Python version management, and environment management), and arguably still does (MKL et al, paid packages). But ever since wheels became <a href="https://pythonwheels.com/">ubiquitous and painless</a>, and virtualenv was <a href="https://docs.python.org/3/library/venv.html">integrated into Python</a>, and the development of PyEnv, these issues now have better solutions, and conda is no longer needed for my applications.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
the downside of compilation is: no Windows support.
</p></div>


</div>
</div><div class="post-date">19 Nov 2017</div><h1 class="post-title"><a href="http://bastibe.de/2017-11-19-emacs-on-windows.html">Installing Emacs on Windows</a></h1>
<p>
The <a href="https://www.gnu.org/software/emacs/download.html#windows">official website</a> states that you need to download Emacs from a <a href="http://ftpmirror.gnu.org/emacs/windows">nearby GNU mirror</a>. However, this does not install gnutls, which is required for installing packages from <a href="http://melpa-stable.milkbox.net/#/">melpa</a> or <a href="https://marmalade-repo.org/">marmalade</a>. The <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs-gnutls/Help-For-Users.html">documentation</a> says that this can be obtained from <a href="https://sourceforge.net/projects/ezwinports/files/">ezwinports</a>.
</p>

<p>
However, I have found that this does not work any more: As of Emacs 25, Emacs is available in 64 bit, but ezwinport only supplies 32 bit binaries. I had to search a bit, but the (in retrospect, obvious) solution is to download the required binaries from <a href="https://gnutls.org/download.html">GnuTLS's website</a>, directly. Then unpack all <code>*.dll</code> from the <code>bin</code> directory to your Emacs's <code>bin</code> directory, and you are good to go.
</p>

<p>
This situation is really a bit sad. Installing Emacs should not be this hard. But there is <a href="https://lists.gnu.org/archive/html/emacs-devel/2017-10/msg00805.html">talk</a> about providing a Windows installer for Emacs in one of the next versions, which will hopefully fix these issues.
</p>
<div class="post-date">24 Oct 2017</div><h1 class="post-title"><a href="http://bastibe.de/2017-10-24-the-long-game.html">The Long Game</a></h1>
<p>
Here's a thing I do: I write open source libraries that solve my problems. <i>Bad</i> libraries. And then, over the course of a year or two, I slowly improve them, until they are not so bad any more.
</p>

<p>
I have gone through this pattern a few times now. <a href="https://github.com/bastibe/PySoundFile">SoundFile</a> started out buggy and slow. <a href="https://github.com/bastibe/transplant">Transplant</a> crashed and froze very often. <a href="https://github.com/bastibe/org-journal">Org-Journal</a> deleted journal entries every now and then. But then users found errors, and errors were fixed. And slowly, over time, these libraries transformed from buggy prototypes into dependable tools. After a year or so, I saw Github Issues gradually drying up, and feedback changing from "X is broken" to "How can I do X?". It is an oddly gratifying process.
</p>

<p>
Interestingly though, I rarely hear people talking about this, that building a thing is only the beginning, and the meat of open source development is sticking with it for a long time, and gradually, slowly, weeding out the bugs. All great open source libraries I know evolved this way, yet it is rarely written about.
</p>

<p>
Playing the long game means anticipating and managing the amount of maintenance I am going to do on a project. When releasing a new library, the first few months and users will shake out bugs, and create work for the maintainers. This can be a dangerous source of stress and anxiety. I've had my brush with burnout in the past, and my only defense to this is to be honest about my availability. Often, this means stating outright that I probably won't have the time to work on a thing.
</p>

<p>
However, I have also learned that it is OK to defer issues to the future. There have been many problems that I didn't have the time to address when they first came up, but <i>did</i> address a few months later, probably in response to a separate bug report. Important problems have a way of getting fixed eventually. Other times, a solution just takes a long time to mature. There have been multiple issues that lay dormant for months until I stumbled upon a good solution.
</p>

<p>
And good solutions are important for open source software: If a bug fix adds too much complexity, it will inevitably lead to <i>more</i> bugs. This can easily snowball into a situation where each hour I invest into a project creates <i>more hours</i> of future maintenance burden. A situation like this feels hopeless and terrible. It feels like work. It is therefore important for my sanity to control the complexity of my projects, even if that means not adding features or not addressing problems. Open source development is not beholden to the dollar sign, and gives you the freedom to do it <i>right</i>.
</p>

<p>
This is not universally understood by programmers or users. And it doesn't just involve technical questions: Some users have expected me to provide commercial-grade support, and got surprisingly unpleasant when I didn't. But it is crucial to realize that publishing open source software <i>does not imply an obligation to fix every issue right now</i>. Quite on the contrary, many open source developers necessarily work on their own schedule, and part of the enjoyment of open source development is derived from this exact freedom!
</p>

<p>
At this point, my Github lists a bunch of open source projects. Some of them have gotten attention, which lead to bug reports, and, over time, let them grow to maturity. Some turned out to be <a href="https://github.com/bastibe/annotate.el">useful</a> <a href="https://github.com/bastibe/twilight">to</a> <a href="https://github.com/bastibe/org-static-blog">me</a>, but not to others. Some are useful <a href="https://github.com/bastibe/Violinplot-Matlab">to</a> <a href="https://github.com/bastibe/lunatic-python">others</a>, but not to me. Some turned out to be not useful <a href="https://github.com/bastibe/MatlabCodeAnalyzer">at all</a>, and are now largely abandoned. And some of them, like <a href="https://github.com/bastibe/RunForrest">RunForrest</a> and <a href="https://github.com/bastibe/SoundCard">SoundCard</a>, are still new and raw and terrible, but will mature over time.
</p>

<p>
That's a thing I do: I write open source libraries. <i>Good</i> libraries, but as a <a href="https://en.wikiquote.org/wiki/Piet_Hein">wise man</a> once said "When you feel how depressingly / slowly you climb, / it's well to remember that / Things Take Time". Working on open source grants you this freedom, and is joyful for it.
</p>
<div class="post-date">19 Sep 2017</div><h1 class="post-title"><a href="http://bastibe.de/2017-09-19-multi-font-themes.html">Multi-Font Themes in Emacs</a></h1>
<p>
Traditionally, text editor themes are all about colors, right? In programming, we use color to tell variables from type declarations, comments, or strings. However, any other text document uses typography instead of color to distinguish between headlines, list items, and keywords. I think that our current approach to highlighting code is misguided.
</p>

<p>
I think that color themes are an accident of history. Terminal text editors are unable to switch fonts. All they can do is switch colors, so colors is all we use. But in todays graphical world, we are no longer bound by the shackles of terminals, and Emacs can switch fonts just as easily as colors<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>.
</p>

<p>
It all started about a year ago, when I fell in love with a font called <a href="https://www.fsd.it/shop/fonts/pragmatapro/">PragmataPro</a>. One of the coolest features of Pragmata was its native bold and italic letters, and its wide support for unicode symbols. I had to find a use for these features! And so, down the rabbit hole I went. <b>Keywords</b> should be bold! <i># Comments</i> should be italic! And while we're at it, why not add some <span class="underline">underlines</span>? And so on.
</p>

<p>
The logical next step was then to get rid of colors altogether. At first, as an experiment. Do I really <i>need</i> colors in code? The very pretty <a href="https://github.com/maio/eink-emacs">eink theme</a> seemed to claim otherwise. After a few months of this lunacy, I realized that while I didn't strictly <i>need</i> colors, the stylistic variations of just one font aren't quite sufficient for source code. In particular, it wasn't always easy to distinguish between italic and roman type in PragmataPro, which lead to some confusion.
</p>

<p>
But then, inspiration hit me: Who says that I could only use one single font? No one!
</p>


<div class="figure">
<p><img src="http://bastibe.de/static/2017-09/color%20theme.png" alt="color%20theme.png" />
</p>
</div>

<p>
The tricky bit is to find fonts that work well together. In this example, I'm using PragmataPro for all regular code, <a href="https://be5invis.github.io/Iosevka/">Iosevka</a> Slab<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup> for strings, and oblique<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> Iosevka for comments. <a href="http://font.ubuntu.com/">Ubuntu Mono</a> and <a href="http://input.fontbureau.com/">InputCompressed</a> work well, too. You can find my current theme <a href="https://github.com/bastibe/.emacs.d/blob/master/lisp/my-eink-theme.el">on Github</a>. The only downside is that while these fonts share the character width, the heights differ slightly, which sometimes leads to uneven line heights.
</p>

<p>
Still, I love the look of this! (Of course it won't work in a terminal, or most other text editors.)
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
: Can other text editors do this? I honestly have no idea.
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
: I just love the look of the slab-serif characters in Iosevka! Look at the beautiful <code>"}"</code> in the screenshot!
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
: not to be confused with <i>italic</i>, which changes glyphs in addition to slanting.
</p></div>


</div>
</div><div id="archive">
  <a href="archive.html">Older posts</a>
</div>
</div>
</body>
