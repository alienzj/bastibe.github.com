<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="alternate"
      type="appliation/rss+xml"
      href="http://bastibe.de/rss.xml"
      title="RSS feed for http://bastibe.de/">
<title>Bastibe.de</title><meta  name="author" content="Bastian Bechtold" />
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> </script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="http://bastibe.de">Basti's Scratchpad on the Internet</a>
  <div class="sitelinks">
    <a href="http://alpha.app.net/bastibe">alpha.app.net</a> | <a href="http://github.com/bastibe">Github</a>
  </div>
</div></div>
<div id="content"><div class="post-date">13 Mar 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-03-13-code-quality-in-scientific-code.html">The Style of Scientific Code</a></h1>
<p>
What does quality code look like? One common school of thought focuses on small, descriptive functions that take few arguments. To quote from <a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin">Clean Code</a>: "The first rule of functions is that they should be small", on the order of less than ten lines. "Functions should not be large enough to hold nested structures". "The ideal number of arguments for a function is zero [, one, or two]. Three [or more] arguments should be avoided where possible".
</p>

<p>
A few years ago, when I was working mostly on user interaction and data management, all of this made sense to me. What is the overhead of a few function calls and class lookups here and there if it makes the code more readable? In other words: Readability counts, and is usually more important than performance.
</p>

<p>
But lately, I have come to struggle with these rules. I am now writing a lot of scientific code, where algorithms are intrinsically complex beyond the syntactic complexity of the code. How do you "Express yourself in code [instead of comments]", when that code only consists of linear algebra and matrix multiplications?
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #1c9af1;">def</span> <span style="color: #d7a924;">rectwin_spectrum</span>(angular_frequency, specsize):
    <span style="color: #9d8567;">"""The spectrum of a rectangular window. [...]"""</span>
    <span style="color: #919191;"># </span><span style="color: #919191;">In case of angular_frequency == 0, this will calculate NaN. Since</span>
    <span style="color: #919191;"># </span><span style="color: #919191;">this will be corrected later, suppress the warning.</span>
    <span style="color: #1c9af1;">with</span> np.errstate(invalid=<span style="color: #9d8567;">'ignore'</span>):
        <span style="color: #379a6a;">spectrum</span> = ( np.exp(-1j*angular_frequency*(specsize-1)/2) *
                     np.sin(specsize*angular_frequency/2) /
                     np.sin(angular_frequency/2) )
    <span style="color: #919191;"># </span><span style="color: #919191;">since sin(x) == x for small x, the above expression</span>
    <span style="color: #919191;"># </span><span style="color: #919191;">evaluates to specsize for angular_frequency == 0.</span>
    <span style="color: #379a6a;">spectrum</span>[angular_frequency == 0.0] = specsize
    <span style="color: #1c9af1;">return</span> spectrum
</pre>
</div>

<p>
A lot of my scientific code ends up quite compact like that. Maybe a hundred lines of dense numeric expressions, plus a few hundred lines of explanations and documentation. The point is, scientific code often does not decompose into easily understood extractable functions.
</p>

<p>
On a related issue, how do you avoid long argument lists in heavily parametrized equations? As Clean Code states, "when a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped in a class of their own". However, in Matlab in particular, it is quite unusual to create small one-trick classes to encapsulate a few function arguments:
</p>

<div class="org-src-container">

<pre class="src src-octave"><span style="color: #1c9af1;">classdef</span> SignalBlocks <span style="color: #d87a00;">&lt;</span> handle
    <span style="color: #1c9af1;">properties</span>
        data
        samplerate
        blocksize
        hopsize
    <span style="color: #1c9af1;">end</span>
    <span style="color: #1c9af1;">properties</span> (Dependent)
        duration
    <span style="color: #1c9af1;">end</span>
    <span style="color: #1c9af1;">methods</span>
        <span style="color: #1c9af1;">function</span> obj <span style="color: #d87a00;">=</span> <span style="color: #d7a924;">SignalBlock</span>(data<span style="color: #d87a00;">,</span> samplerate<span style="color: #d87a00;">,</span> blocksize<span style="color: #d87a00;">,</span> hopsize)
            <span style="color: #919191;">% blocksize and hopsize are optional. What a mess.</span>
            narginchk(2<span style="color: #d87a00;">,</span> 4)<span style="color: #d87a00;">;</span>
            obj.data <span style="color: #d87a00;">=</span> data<span style="color: #d87a00;">;</span>
            obj.samplerate <span style="color: #d87a00;">=</span> samplerate<span style="color: #d87a00;">;</span>
            <span style="color: #1c9af1;">if</span> nargin <span style="color: #d87a00;">&gt;=</span> 3
                obj.blocksize <span style="color: #d87a00;">=</span> blocksize<span style="color: #d87a00;">;</span>
            <span style="color: #1c9af1;">else</span>
                obj.blocksize <span style="color: #d87a00;">=</span> 2048<span style="color: #d87a00;">;</span>
            <span style="color: #1c9af1;">end</span>
            <span style="color: #1c9af1;">if</span> nargin <span style="color: #d87a00;">==</span> 4
                obj.hopsize <span style="color: #d87a00;">=</span> hopsize<span style="color: #d87a00;">;</span>
            <span style="color: #1c9af1;">else</span>
                obj.hopsize <span style="color: #d87a00;">=</span> 1024<span style="color: #d87a00;">;</span>
            <span style="color: #1c9af1;">end</span>
        <span style="color: #1c9af1;">end</span>
        <span style="color: #1c9af1;">function</span> time <span style="color: #d87a00;">=</span> <span style="color: #d7a924;">get</span>.duration(obj)
            time <span style="color: #d87a00;">=</span> length(obj.data)<span style="color: #d87a00;">/</span>obj.samplerate<span style="color: #d87a00;">;</span>
        <span style="color: #1c9af1;">end</span>
    <span style="color: #1c9af1;">end</span>
<span style="color: #1c9af1;">end</span>
</pre>
</div>

<p>
This is not just cumbersome to write and maintain, it is also slower than passing <code>data</code>, <code>samplerate</code>, <code>blocksize</code>, and <code>hopsize</code> to each function call individually (although the overhead has gotten considerably smaller in newer versions of Matlab). Additionally, there is often a large performance benefit of <i>not</i> extracting every function and <i>not</i> keeping intermediate values in variables. Thus, it's not just readability that is hard to maintain in scientific code. Performance is a problem, too.
</p>

<p>
The sad thing is, I don't know the answer to these questions. There have been a lot of discussions about coding style and code quality in our department lately, with the clear objective to clean up our code. But common code quality criteria don't seem to apply to scientific code all that well.
</p>

<p>
Do you have any idea how to progress from here?
</p>
<div class="post-date">23 Jan 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-01-23-toren.html">Toren</a></h1>
<p>
I've been playing a lot of indie games lately. One of them has not been talked about much: <a href="http://toren-game.com/">Toren</a>. Toren is a platformer about a girl that has to climb a tower to defeat a dragon and revive her world. This is probably the least polished game I have played in a long time. Animations are janky, controls are imprecise and clunky, and there are loads of little glitches. Yet, I really enjoyed this.
</p>

<p>
There is something about this world that feels honest to me: As you climb the tower, the child grows from a toddler to an adolescent, and is gradually introduced to more and more mature concepts. I didn't understand much of the iconography of this game, but it felt oddly cathartic to climb this tower of life, and overcome it's challenges.
</p>

<p>
I particularly liked how death played such an integral role in this story and some of the puzzles. The tower is a monument to a dead people, and yet the story and game mechanics are as much about dying as they are about rebirth and not giving up. This is underlined by the wonderful art style of this game, which contrasts vivid colors with brooding, dark architecture.
</p>

<p>
At just about two hours, Toren is not a long game. Instead of exploring one particular game mechanic, it mixes it's game up every few minutes. Every sequence looks different and beautiful, and yet it manages to tell a cohesive and effective story. ★★★★☆
</p>
<div class="post-date">06 Jan 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-01-06-books-of-2015.html">Books of 2015</a></h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><a href="https://www.goodreads.com/book/show/8706185-among-others">Among Others</a>, by Jo Walton</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p style="float:left;margin:5px;" width="150px">
<img src="https://upload.wikimedia.org/wikipedia/en/d/d1/Among_Others_(Jo_Walton_novel).jpg" alt="Among_Others_(Jo_Walton_novel).jpg" style="float:left;margin:5px;" width="150px" />
I don't usually enjoy fantasy novels and their romantic escapism. I much prefer fascinating sci-fi thought experiments. But this book won all the most important awards, so I gave it a shot. What if random chance could be bent a little with creativity, the power of believing in something, and some mysticism? You end up with a world that is richer, more meaningful, and altogether more alive, if you just cared to observe and to appreciate it's beauty. Reading this book left me enchanted and more observant long after I put it down. What a wonderful book!
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><a href="https://www.goodreads.com/book/show/7073.A_Son_of_the_Circus">A Son of the Circus</a>, by John Irving</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p style="float:left;margin:5px;" width="150px">
<img src="https://upload.wikimedia.org/wikipedia/en/e/e7/ASonOfTheCircus.JPG" alt="ASonOfTheCircus.JPG" style="float:left;margin:5px;" width="150px" />
This is one of those books that was on my to-read list for months. It starts out as quirky and likeable as you would expect from John Irving. This time, we follow the tale of a Canadian/Indian doctor throughout his life, and his summer vacation in India. But this would not be John Irving if there weren't plenty of colourful characters, astute observations of human strangeness, and a meticulously crafted story. There is no scene in this book that does not serve a purpose, and so many moving parts my mind just boggles at the construction of it all. Yet at the same time, I was regularly laughing out loud. I loved every minute of this!
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><a href="https://www.goodreads.com/book/show/6597651-the-windup-girl">The Windup Girl</a>, by Paolo Bacigalupi</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p style="float:left;margin:5px;" width="150px">
<img src="https://upload.wikimedia.org/wikipedia/en/1/1f/Wind_up.jpg" alt="Wind_up.jpg" style="float:left;margin:5px;" width="150px" />
The whole world changed in the near future, when gasoline is a rare luxury, sea levels have risen and swallowed all the coastal cities, and man-made scourges have devastated most crops. And now it's not just humans that populate our urbanized world, but so too are our inventions, artificial humans called "windups" for their stutter-stop movements. But at the core, both humans and windups struggle for the same security, prosperity as ever. Such an inventive world, so much vivid creativity, social commentary, in this human struggle to not destroy ourselves.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><a href="https://www.goodreads.com/book/show/629.Zen_and_the_Art_of_Motorcycle_Maintenance">Zen and the art of motorcycle maintenance</a>, by Robert Pirsig</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p style="float:left;margin:5px;" width="150px">
<img src="https://upload.wikimedia.org/wikipedia/en/8/85/Zen_motorcycle.jpg" alt="Zen_motorcycle.jpg" style="float:left;margin:5px;" width="150px" />
This is about equal parts a motorcycle journey of a father and his son across the US, and a dive into another man's discoveries of philosophy. To be honest, I liked this book more for it's character descriptions and travelling adventures than it's philosophy. I am really conflicted about putting this book on this list at all, but I kept thinking about this long after I finished reading it, so I guess this had a bigger influence on me than I realized.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">Nexus/Crux/Apex, Rad/Blue/Green Mars, The Martian, The Three-Body Problem</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
What happens when you take today's world, and add nanotech brain upgrades (Nexus/Crux/Apex), or strand a lone scientist on Mars (The Martian), or send a large number of people to found a new colony on Mars (Red/Blue/Green Mars), or suddenly make contact with Aliens (The Three-Body Problem)? This what-if is what Science Fiction does best: Take this little what-if, and spin a gripping yarn from that. These books inspired me, made me think, were incredibly thrilling, but they did not have a lasting impact. Still well worth a read if you like Science Fiction, though.
</p>
</div>
</div>
<div class="post-date">03 Nov 2015</div><h1 class="post-title"><a href="http://bastibe.de/2015-11-03-matlab-engine-performance.html">Calling Matlab from Python</a></h1>
<p>
For my latest experiments, I needed to run both Python functions and Matlab functions as part of the same program. As I <a href="http://bastibe.de/2015-10-29-matlab-engine-leaks.html">noted earlier</a>, Matlab includes the <a href="http://mathworks.com/help/matlab/matlab-engine-for-python.html">Matlab Engine for Python</a> (MEfP), which can call Matlab functions from Python. Before I knew about this, I created <a href="https://github.com/bastibe/transplant">Transplant</a>, which does the very same thing. So, how do they compare?
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Usage</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
As it's name suggests, Matlab is a <b>mat</b>rix <b>lab</b>oratory, and matrices are the most important data type in Matlab. Since matrices don't exist in plain Python, the MEfP implements it's own as <code>matlab.double</code> et al., and you have to convert any data you want to pass to Matlab into one of those. In contrast, Transplant recognizes the fact that Python does in fact know a really good matrix engine called <a href="http://scipy.org/">Numpy</a>, and just uses that instead.
</p>

<pre class="example">
       Matlab Engine for Python        |              Transplant
---------------------------------------|---------------------------------------
import numpy                           | import numpy
import matlab                          | import transplant
import matlab.engine                   |
                                       |
eng = matlab.engine.start_matlab()     | eng = transplant.Matlab()
numpy_data = numpy.random.randn(100)   | numpy_data = numpy.random.randn(100)
list_data = numpy_data.tolist()        |
matlab_data = matlab.double(list_data) |
data_sum = eng.sum(matlab_data)        | data_sum = eng.sum(numpy_data)
</pre>

<p>
Aside from this difference, both libraries work almost identical. Even the handling of the number of output arguments is (accidentally) almost the same:
</p>

<pre class="example">
       Matlab Engine for Python        |              Transplant
---------------------------------------|---------------------------------------
eng.max(matlab_data)                   | eng.max(numpy_data)
&gt;&gt;&gt; 4.533                              | &gt;&gt;&gt; [4.533 537635]
eng.max(matlab_data, nargout=1)        | eng.max(numpy_data, nargout=1)
&gt;&gt;&gt; 4.533                              | &gt;&gt;&gt; 4.533
eng.max(matlab_data, nargout=2)        | eng.max(numpy_data, nargout=2)
&gt;&gt;&gt; (4.533, 537635.0)                  | &gt;&gt;&gt; [4.533 537635]
</pre>

<p>
Similarly, both libraries can interact with Matlab objects in Python, although the MEfP can't access object properties:
</p>

<pre class="example">
       Matlab Engine for Python        |              Transplant
---------------------------------------|---------------------------------------
f = eng.figure()                       | f = eng.figure()
eng.get(f, 'Position')                 | eng.get(f, 'Position')
&gt;&gt;&gt; matlab.double([[ ... ]])           | &gt;&gt;&gt; array([[ ... ]])
f.Position                             | f.Position
&gt;&gt;&gt; AttributeError                     | &gt;&gt;&gt; array([[ ... ]])
</pre>

<p>
There are a few small differences, though:
</p>

<ul class="org-ul">
<li>Function documentation in the MEfP is only available as <code>eng.help('funcname')</code>. Transplant will populate a function's <code>__doc__</code>, and thus documentation tools like IPython's <code>?</code> operator just work.</li>
<li>Transplant converts empty matrices to <code>None</code>, whereas the MEfP represents them as <code>matlab.double([])</code>.</li>
<li>Transplant represents <code>dict</code> as <code>containers.Map</code>, while the MEfP uses <code>struct</code> (the former is more correct, the latter arguable more useful).</li>
<li>If the MEfP does not know <code>nargout</code>, it assumes <code>nargout=1</code>. Transplant uses <code>nargout(func)</code> or returns whatever the function writes into <code>ans</code>.</li>
<li>The MEfP can't return non-scalar structs, such as the return value of <code>whos</code>. Transplant can do this.</li>
<li>The MEfP can't return anonymous functions, such as <code>eng.eval('@(x, y) x&gt;y')</code>. Transplant can do this.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Performance</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
The time to start a Matlab instance is shorter in MEfP (3.8 s) than in Transplant (6.1 s). But since you're doing this relatively seldomly, the difference typically doesn't matter too much.
</p>

<p>
More interesting is the time it takes to call a Matlab function from Python. Have a look:
</p>


<div class="figure">
<p><img src="http://bastibe.de/static/2015-11/execution%20time.png" alt="execution%20time.png" />
</p>
</div>

<p>
This is running <code>sum(randn(n,1))</code> from Transplant, the MEfP, and in Matlab itself. As you can see, the MEfP is a constant factor of about 1000 slower than Matlab. Transplant is a constant factor of about 100 slower than Matlab, but always takes at least 0.05 s.
</p>

<p>
There is a gap of about a factor of 10 between Transplant and the MEfP. In practice, this gap is highly significant! In my particular use case, I have <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxpefac.html">a function</a> that takes about one second of computation time for an audio signal of ten seconds (half a million values). When I call this function with Transplant, it takes about 1.3 seconds. With MEfP, it takes 4.5 seconds.
</p>

<p>
Transplant spends its time serializing the arguments to JSON, sending that JSON over <a href="http://zeromq.org/">ZeroMQ</a> to Matlab, and parsing the JSON there. Well, to be honest, only the parsing part takes any significant time, overall. While it might seem onerous to serialize everything to JSON, this architecture allows Transplant to run over a network connection.
</p>

<p>
It is a bit baffling to me that MEfP manages to be slower than <i>that</i>, despite being written in C. Looking at the number of function calls in the profiler, the MEfP calls 25 functions (!) on each value (!!) of the input data. This is a shockingly inefficient way of doing things.
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">TL;DR</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
It used to be very difficult to work in a mixed-language environment, particularly with one of those languages being Matlab. Nowadays, this has thankfully gotten much easier. Even Mathworks themselves have stepped up their game, and can interact with Python, C, Java, and FORTRAN. But their interface to Python does leave something to be desired, and there are better alternatives available.
</p>

<p>
If you want to try Transplant, just head over to <a href="https://github.com/bastibe/transplant">Github</a> and use it. If you find any bugs, feature requests, or improvements, please let me know in the Github issues.
</p>
</div>
</div>
<div class="post-date">29 Oct 2015</div><h1 class="post-title"><a href="http://bastibe.de/2015-10-29-matlab-engine-leaks.html">Massive Memory Leak in the Matlab Engine for Python</a></h1>
<p>
As of Matlab 2014b, Matlab includes a <a href="http://mathworks.com/help/matlab/matlab-engine-for-python.html">Python module</a> for calling Matlab code from Python. This is how you use it:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #1c9af1;">import</span> numpy
<span style="color: #1c9af1;">import</span> matlab
<span style="color: #1c9af1;">import</span> matlab.engine

<span style="color: #379a6a;">eng</span> = matlab.engine.start_matlab()
<span style="color: #379a6a;">random_data</span> = numpy.random.randn(100)
<span style="color: #919191;"># </span><span style="color: #919191;">convert Numpy data to Matlab:</span>
<span style="color: #379a6a;">matlab_data</span> = matlab.double(random_data.tolist())
<span style="color: #379a6a;">data_sum</span> = eng.<span style="color: #d87a00;">sum</span>(matlab_data)
</pre>
</div>

<p>
You can call any Matlab function on <code>eng</code>, and you can access any Matlab workspace variable in <code>eng.workspace</code>. As you can see, the Matlab Engine is not Numpy-aware, and you have to convert all your Numpy data to Matlab <code>double</code> before you can call Matlab functions with it. Still, it works pretty well.
</p>

<p>
Recently, I ran a rather large experiment set, where I had a set of four functions, two in Matlab, two in Python, and called each of these functions a few thousand times with a bunch of different data to see how they performed.
</p>

<p>
While doing that I noticed that my Python processes were growing larger and larger, until they consumed all my memory and a sizeable chunk of my swap as well. I couldn't find any reason for this. None of my Python code cached anything, and the sum total of all global variables did not amount to anything substantial.
</p>

<p>
Enter <a href="http://pythonhosted.org/Pympler/index.html">Pympler</a>, a memory analyzer for Python. Pympler is an amazing library for introspecting your program's memory. Among its many features, it can list the biggest objects in your running program:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #1c9af1;">from</span> pympler <span style="color: #1c9af1;">import</span> muppy, summary
summary.print_(summary.summarize(muppy.get_objects()))
</pre>
</div>

<pre class="example">
                                      types |   # objects |   total size
=========================================== | =========== | ============
                        &lt;class 'array.array |        1076 |      2.77 GB
                                &lt;class 'str |       42839 |      7.65 MB
                               &lt;class 'dict |        8604 |      5.43 MB
                      &lt;class 'numpy.ndarray |          48 |      3.16 MB
                               &lt;class 'code |       14113 |      1.94 MB
                               &lt;class 'type |        1557 |      1.62 MB
                               &lt;class 'list |        3158 |      1.38 MB
                                &lt;class 'set |        1265 |    529.72 KB
                              &lt;class 'tuple |        5129 |    336.98 KB
                              &lt;class 'bytes |        2413 |    219.48 KB
                            &lt;class 'weakref |        2654 |    207.34 KB
            &lt;class 'collections.OrderedDict |          65 |    149.85 KB
                 &lt;class 'wrapper_descriptor |        1676 |    130.94 KB
  &lt;class 'traitlets.traitlets.MetaHasTraits |         107 |    123.55 KB
                  &lt;class 'getset_descriptor |        1738 |    122.20 KB
</pre>

<p>
Now that is interesting. Apparently, I was lugging around close to three gigabytes worth of bare-Python <code>array.array</code>. And these are clearly not Numpy arrays, since those would show up as <code>numpy.ndarray</code>. But I couldn't find any of these objects in my workspace.
</p>

<p>
So let's get a reference to one of these objects, and see who they belong to. This can also be done with Pympler, but I prefer the way <a href="http://mg.pov.lt/objgraph/">objgraph</a> does it:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #1c9af1;">import</span> array
<span style="color: #919191;"># </span><span style="color: #919191;">get a list of all objects known to Python:</span>
<span style="color: #379a6a;">all_objects</span> = muppy.get_objects()
<span style="color: #919191;"># </span><span style="color: #919191;">sort out only `array.array` instances:</span>
<span style="color: #379a6a;">all_arrays</span> = [obj <span style="color: #1c9af1;">for</span> obj <span style="color: #1c9af1;">in</span> all_objects <span style="color: #1c9af1;">if</span> <span style="color: #d87a00;">isinstance</span>(obj, array.array)]

<span style="color: #1c9af1;">import</span> objgraph
objgraph.show_backrefs(all_arrays[0], filename=<span style="color: #9d8567;">'array.png'</span>)
</pre>
</div>


<div class="figure">
<p><img src="http://bastibe.de/static/2015-10/array.png" alt="array.png" />
</p>
</div>

<p>
It seems that the <code>array.array</code> object is part of a <code>matlab.double</code> instance which is not referenced from anywhere but <code>all_objects</code>. A memory leak.
</p>

<p>
After a bit of experimentation, I found the culprit. To illustrate, here's an example: The function <code>leak</code> passes some data to Matlab, and calculates a float. Since the variables are not used outside of <code>leak</code>, and the function does not return anything, all variables within the function should get deallocated when <code>leak</code> returns.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #1c9af1;">def</span> <span style="color: #d7a924;">leak</span>():
    <span style="color: #379a6a;">test_data</span> = numpy.zeros(1024*1024)
    <span style="color: #379a6a;">matlab_data</span> = matlab.double(test_data.tolist())
    eng.<span style="color: #d87a00;">sum</span>(matlab_data)
</pre>
</div>

<p>
Pympler has another great feature that can track allocations. The <code>SummaryTracker</code> will track and display any allocations between calls to <code>print_diff()</code>. This is very useful to see how much memory was used during the call to <code>leak</code>:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #1c9af1;">from</span> pympler <span style="color: #1c9af1;">import</span> tracker
<span style="color: #379a6a;">tr</span> = tracker.SummaryTracker()
tr.print_diff()
leak()
tr.print_diff()
</pre>
</div>

<pre class="example">
                     types |   # objects |   total size
========================== | =========== | ============
       &lt;class 'array.array |           1 |      8.00 MB
...
</pre>

<p>
And there you have it. Note that this leak is not the Numpy array <code>test_data</code> and it is not the matlab array <code>matlab_data</code>. Both of these are garbage collected correctly. But <b>the Matlab Engine for Python will leak any data you pass to a Matlab function</b>.
</p>

<p>
This data is not referenced from anywhere within Python, and is counted as <i>leaked</i> by <code>objgraph</code>. In other words, the C code inside the Matlab Engine for Python copies all passed data into it's internal memory, but never frees that memory. Not even if you quit the Matlab Engine, or <code>del</code> all Python references to it. Your only option is to restart Python.
</p>

<p>
<b>Postscriptum</b>
</p>

<p>
I since posted a bug report on Mathworks, and received a patch that fixes the problem. Additionally, Mathworks said that the problem only occurs on Linux.
</p>
<div id="archive">
  <a href="archive.html">Older posts</a>
</div>
</div>
</body>
