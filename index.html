<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="alternate"
      type="appliation/rss+xml"
      href="http://bastibe.de/rss.xml"
      title="RSS feed for http://bastibe.de/">
<title>Bastibe.de</title>
<meta  name="author" content="Bastian Bechtold" />
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> </script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="http://bastibe.de">Basti's Scratchpad on the Internet</a>
  <div class="sitelinks">
    <a href="https://twitter.com/paperflyer">Twitter</a> | <a href="http://github.com/bastibe">Github</a>
  </div>
</div></div>
<div id="content">

<div class="post-date">10 Apr 2018</div><h1 class="post-title"><a href="2018-04-10-appending-to-matlab-arrays.html">Appending to Matlab Arrays</a></h1>
<p>
<i>The variable $var appears to change size on every loop iteration. Consider preallocating for speed.</i>
</p>

<p>
So sayeth Matlab.
</p>

<p>
Let's try it:
</p>

<div class="org-src-container">

<pre class="src src-octave">x_prealloc <span style="color: #111111;">=</span> cell(10000<span style="color: #111111;">,</span> 1)<span style="color: #111111;">;</span>
x_end <span style="color: #111111;">=</span> {}<span style="color: #111111;">;</span>
x_append <span style="color: #111111;">=</span> {}<span style="color: #111111;">;</span>
<span style="color: #111111; font-weight: bold;">for</span> n<span style="color: #111111;">=</span>1<span style="color: #111111;">:</span>10000
    <span style="color: #111111; font-style: italic;">% variant 1: preallocate</span>
    x_prealloc(n) <span style="color: #111111;">=</span> {42}<span style="color: #111111;">;</span>
    <span style="color: #111111; font-style: italic;">% variant 2: end+1</span>
    x_end(end<span style="color: #111111;">+</span>1) <span style="color: #111111;">=</span> {42}<span style="color: #111111;">;</span>
    <span style="color: #111111; font-style: italic;">% variant 3: append</span>
    x_append <span style="color: #111111;">=</span> [x_append {42}]<span style="color: #111111;">;</span>
<span style="color: #111111; font-weight: bold;">end</span>
</pre>
</div>

<p>
Which variant do you think is fastest?
</p>


<div class="figure">
<p><img src="./static/2018-04/array_performance.png" alt="array_performance.png" />
</p>
</div>

<p>
Unsurprisingly, preallocation is indeed faster than growing an array. What <i>is</i> surprising is that it is faster by a constant factor of about 2 instead of scaling with the array length. Only appending by <code>x = [x {42}]</code> actually becomes slower for larger arrays. (The same thing happens for numerical arrays, struct arrays, and object arrays.)
</p>

<p>
<b>TL;DR:</b> Do not use <code>x = [x $something]</code>, ever. Instead, use <code>x(end+1) = $something</code>. Preallocation is generally overrated.
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-matlab.html">matlab</a> </div>
<div class="post-date">07 Apr 2018</div><h1 class="post-title"><a href="2018-04-07-defeating-news-addiction.html">Defeating News Addiction</a></h1>
<p>
I want to consume the news, both because it is genuinely relevant for my work, and because conversations about news are part of my social life. But I do not want to be consumed by news, and end up scanning news websites over and over for new content, even though you know that the likelihood of finding anything interesting is small.
</p>

<p>
Over the last few months, I have tried hard to find all instances of this repeated-scanning behavior, and eliminate it. The key is to automate the scanning such that I am only ever presented with new content, but do not get hooked on the addictive variable-reward cycle of checking websites for changes over and over again.
</p>

<p>
And it all works thank to the magic of RSS:
</p>

<ul class="org-ul">
<li><b>News Sources:</b>
  I read several blogs, newspapers, and webcomics. All of them have RSS feeds. Easy.
</li>

<li><b>Hacker News:</b>
  The brilliant service <a href="https://hnrss.org/">hnrss.org</a> provides RSS feeds for Hacker News, and filters them to for example only include posts that made it to the front page, and have accumulated <a href="https://hnrss.org/frontpage?points=100">at least 100 points</a>.
</li>

<li><b>Reddit:</b>
  Every subreddit has its own feed, at <a href="https://www.reddit.com/r/emacs.rss">reddit.com/r/subreddit.rss</a>. Sadly there is no way to filter for a minimum number of upvotes.
</li>

<li><b>YouTube:</b>
  Again, every YouTube channel has its own RSS feed, but Google is trying very hard to make it as cumbersome as possible to get at those feeds. You need to go to your <a href="https://www.youtube.com/subscription_manager">Subscription Manager</a>, then scroll all the way down, and "Export Subscriptions". The resulting file helpfully does not have a file extension, which you will have to add before you can import it into your RSS reader. I honestly can't reconstruct how I found that subscription manager, either, but presumably there is some series of clicks that would take you there.
</li>
</ul>

<p>
With all this settled, I have a veritable firehose of news every day. I estimate that only 1 % of this is actually worth reading. So in the next step, I filter this list for spam. For this purpose, I use <a href="https://feedbin.com/">Feedbin</a>, which aggegates all these feeds, and remembers whether I have read an article. The remaining ham I either read immediately, or forward it to <a href="http://pinboard.in/">Pinboard</a> for later consumption.
</p>

<p>
With this system, I never miss anything, but once I consume all the news in my feed reader, I know I am done, and there is no point in checking and re-checking various websites over and over again.
</p>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="422" height="70">
  <!-- grey achievement box: -->
  <rect x="0" y="1" rx="32" ry="32" width="422" height="64" fill="#3A3E3F" />
  <!-- black background circle: -->
  <circle cx="33" cy="33" r="28" fill="#15150D" />
  <!-- top left sector (green): -->
  <path d="M 9 30
           A 24 24 0 0 1 30 9
           L 30 15
           A 18 18 0 0 0 15 30"
        fill="#69B168" />
  <!-- top right sector (grey): -->
  <path d="M 36 9
           A 24 24 0 0 1 57 30
           L 51 30
           A 18 18 0 0 0 36 15"
        fill="#595B5A" />
  <!-- bottom right sector (grey): -->
  <path d="M 57 36
           A 24 24 0 0 1 36 57
           L 36 51
           A 18 18 0 0 0 51 36"
        fill="#595B5A" />
  <!-- bottom left sector (grey): -->
  <path d="M 30 57
           A 24 24 0 0 1 9 36
           L 15 36
           A 18 18 0 0 0 30 51"
        fill="#595B5A" />
  <!-- XBox image (source unknown): -->
  <image xlink:href="static/2018-04/xbox.png" x="18" y="18" width="30px" height="30px" />
  <!-- text labels: -->
  <text x="76" y="27" font-family="Verdana" font-size="13px" fill="#E1E6E7">ACHIEVEMENT UNLOCKED</text>
  <text x="76" y="48" font-family="Verdana" font-size="13px" fill="#E1E6E7">Defeated News Addiction!</text>
</svg>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-workflow.html">workflow</a> </div>
<div class="post-date">02 Apr 2018</div><h1 class="post-title"><a href="2018-04-02-scheduling-future-todos-in-org-journal.html">Scheduling Future TODOs in org-journal</a></h1>
<p>
I keep a simple journal in <a href="https://github.com/bastibe/org-journal">org-journal</a>: One text file per day, in <a href="https://orgmode.org/">org-mode</a>. But over the years, org-journal has grown somewhat beyond this simple use case. <a href="https://github.com/bastibe/org-journal/releases/tag/1.7.1">About three years ago</a>, a gentleman named <a href="https://github.com/vkazanov">Vladimir Kazanov</a> implemented a very fast text search. Thus, my journal became an information archive. <a href="https://github.com/bastibe/org-journal/releases/tag/1.11.0">About two years ago</a>, org-journal learned to carry over TODO items to the current day if you hadn't completed them on the previous day. So it to become a to-do list. And <a href="https://github.com/bastibe/org-journal/releases/tag/1.13.1">today</a>, org-journal gained the ability to work with future journal entries, thus becoming a calendar.
</p>

<p>
Despite all of these features however, org-journal remains one org file per day, with fancy functions to do fancy things if you want them—or ignore them, if the journal is all you need.
</p>

<p>
Back to scheduling: This work was prompted by <a href="https://zngguvnf.org/">my colleague</a>, who organizes everything in org-mode, but is not a user of org-journal. He even eschews the use of a traditional calendar, and instead uses a few org files and the magic of org-agenda to give him a nice overview like this for the coming week<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>:
</p>

<pre>
<span style="color: #111111; font-weight: bold;">Week-agenda (W14):</span>
<span style="color: #111111; font-weight: bold; font-style: italic;">Monday     2 April 2018 W14</span>
<span style="color: #111111;">  2018-04-02: Easter Monday </span>
<span style="color: #111111; font-weight: bold;">Tuesday    3 April 2018</span>
<span style="color: #111111; font-weight: bold;">Wednesday  4 April 2018</span>
<span style="color: #111111; font-weight: bold;">Thursday   5 April 2018</span>
<span style="color: #111111;">  2018-04-05: Scheduled:  Give Lecture 4 on Applied Programming</span>             <span style="color: #111111;"><span style="font-weight: bold;">:BB:</span></span>
<span style="color: #111111; font-weight: bold;">Friday     6 April 2018</span>
<span style="color: #111111;">  2018-04-06: Scheduled:  Release of new Eels record</span>
<span style="color: #111111; font-weight: bold;">Saturday   7 April 2018</span>
<span style="color: #111111; font-weight: bold;">Sunday     8 April 2018</span>
<span style="color: #111111;">  2018-04-08: Scheduled:  </span><span style="color: #111111;">TODO</span><span style="color: #111111;"> Celebrate Sunday</span>
</pre>

<p>
And lo and behold, this now works in org-journal as well! Just create a new journal entry in the future, either by pressing <code>i j</code> in <code>M-x calendar</code> or by calling <code>org-journal-new-scheduled-entry</code>, and org-journal will create an entry with a <code>SCHEDULED</code> property of the appropriate date (prefix to suppress <code>TODO</code>). When the current day reaches that entry, it will incorporate it into the daily journal.
</p>

<p>
Future journal entries are highlighted in <code>M-x calendar</code>, and you can get an overview of them with <code>org-journal-schedule-view</code>, or, if you enable <code>org-journal-enable-agenda-integration</code>, through the ordinary <code>org-agenda</code>, as shown above. The agenda integration does not include past journal entries in the agenda, since agenda searches tend to become very slow if they have to traverse the hundreds of files in my journal.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
: This is of course not <i>his</i> calendar, but mine.
</p></div>


</div>
</div><div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-org-journal.html">org-journal</a> <a href="tag-org-mode.html">org-mode</a> </div>
<div class="post-date">22 Mar 2018</div><h1 class="post-title"><a href="2018-03-22-org-static-blog-gets-tags.html">Blogging with org-static-blog (Updated)</a></h1>
<p>
A while ago, I scratched an old itch and wrote my own static site generator, called <a href="https://github.com/bastibe/org-static-blog">org-static-blog</a>. It is a simple thing: You hand it a directory full of *.org files with a <code>#+title:</code> and <code>#+date:</code>, and it assembles a bunch of HTML pages and an RSS feed from them. There are no external dependencies beyond Emacs.
</p>

<p>
Today, I <a href="http://melpa-stable.milkbox.net/#/org-static-blog">released</a> version 1.1.0 of org-static-blog, which introduces two new features: <a href="http://bastibe.de/2018-03-17-speeding-up-org-static-blog.html">speed</a>, and tags. You can now—optionally—add <code>#+filetags:</code> to your *.org files, <code>(setq org-static-blog-enable-tags t)</code>, and org-static-blog will add tag links to every blog post, create tag indices, and add <code>&lt;category&gt;</code> tags to the RSS feed.
</p>

<p>
<b>Update:</b>
</p>

<p>
As <a href="https://github.com/kaushalmodi">Kaushal Modi</a> pointed out in the comments, org-mode uses <code>#+filetags:</code> to set tags for entire files. My first implementation used <code>#+tags:</code>. This is now deprecated. <code>#+tags:</code> still works, but issues a warning, and will be removed in the future. Sorry for the inconvenience.
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-blog.html">blog</a> </div>
<div class="post-date">17 Mar 2018</div><h1 class="post-title"><a href="2018-03-17-speeding-up-org-static-blog.html">Speeding up org-static-blog</a></h1>
<p>
Three years ago, I had enough of all the static site generators out there. Over the life of this blog, I had used <a href="http://bastibe.de/2012-07-18-blogging-with-pelican.html">Octopress, then Pelican</a>, then <a href="http://bastibe.de/2013-11-13-blogging-with-emacs.html">Coleslaw</a>, then <a href="http://bastibe.de/2014-05-07-speeding-up-org-publishing.html">org-mode</a>, and then wrote my own static site generator, <a href="https://github.com/bastibe/org-static-blog">org-static-blog</a>. Above all, org-static-blog is <i>simple</i>. It iterates over all *.org files in <code>org-static-blog-posts-directory</code>, and then exports all of these files to HTML. Simple is good. Simple is reliable. Simple means I can fix things.
</p>

<p>
However, simple can also mean inefficient. Most glaringly, org-static-blog exports every single blog post three times every time you publish: Once to render the HTML, then once to render the RSS feed, then once to render the Index and Archive pages.
</p>

<p>
Today, I finally tackled this problem: Now, org-static-blog only exports each post once, when the *.org file changes. The RSS feed, the Index page, and the Archive page simply read the already-rendered HTML instead of exporting again.
</p>

<p>
Thus, a full rebuild of this blog and all of its 85 posts used to take 2:12 min, and now takes 42 s. More importantly, if only one org file changed, the rebuild used to take 1:08 min, and now takes 1.5 s. Things like this are hugely satisfying to me!
</p>
<div class="taglist"><a href="tags.html">Tags:</a> <a href="tag-org-mode.html">org-mode</a> <a href="tag-emacs.html">emacs</a> <a href="tag-blog.html">blog</a> </div><div id="archive">
<a href="archive.html">Other posts</a>
</div>
</div>
</body>
