<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="alternate"
      type="appliation/rss+xml"
      href="http://bastibe.de/rss.xml"
      title="RSS feed for http://bastibe.de/">
<title>Bastibe.de</title><meta  name="author" content="Bastian Bechtold" />
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> </script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="http://bastibe.de">Basti's Scratchpad on the Internet</a>
  <div class="sitelinks">
    <a href="http://alpha.app.net/bastibe">alpha.app.net</a> | <a href="http://github.com/bastibe">Github</a>
  </div>
</div></div>
<div id="content"><div class="post-date">20 Jun 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-06-20-transplant-revisited.html">Transplant, revisited</a></h1>
<p>
A few months ago, I <a href="http://bastibe.de/2015-11-03-matlab-engine-performance.html">talked about</a> the performance of calling Matlab from Python. Since then, I implemented a few optimizations that make working with Transplant a lot faster:
</p>


<div class="figure">
<p><img src="http://bastibe.de/static/2016-06/timings.png" alt="timings.png" />
</p>
</div>

<p>
The workload consisted of generating a bunch of random numbers (not included in the times), and sending them to Matlab for computation. This task is entirely dominated by the time it takes to transfer the data to Matlab (see table at the end for intra-language benchmarks of the same task).
</p>

<p>
As you can see, the new Transplant is significantly faster for small workloads, and still a factor of two faster for larger amounts of data. It is now almost always a faster solution than the Matlab Engine for Python (MEfP). For very large datasets, Oct2Py might be preferable, though.
</p>

<p>
This improvement comes from three major changes: Matlab functions are now returned as callable objects instead of ad-hoc functions, Transplant now uses MsgPack instead of JSON, and <code>loadlibrary</code> instead of a Mex file to call into <code>libzmq</code>. All of these changes are entirely under the hood, though, and the public API remains unchanged.
</p>

<p>
The callable object thing is the big one for small workloads. The advantage is that the objects will only fetch documentation if <code>__doc__</code> is actually asked for. As it turns out, running <code>help('funcname')</code> for every function call is kind of a big overhead.
</p>

<p>
Bigger workloads however are dominated by the time it takes Matlab to decode the data. String parsing is very slow in Matlab, which is a bad thing indeed if you're planning to read a couple hundred megabytes of JSON. Thus, I replaced JSON with MsgPack, which eliminates the parsing overhead almost entirely. JSON messaging is still available, though, if you pass <code>msgformat='json'</code> to the constructor.
</p>

<p>
Lastly, I rewrote the ZeroMQ interaction to use <code>loadlibrary</code> instead of a Mex file. This has no impact on processing speed at all, but you don't have to <a href="http://bastibe.de/2016-05-31-Matlab-FFI.html">worry about</a> compiling that C code any more.
</p>

<p>
Oh, and Transplant now works on Windows!
</p>

<p>
Here is the above data again in tabular form:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Task</th>
<th scope="col" class="left">New Transplant</th>
<th scope="col" class="left">Old Transplant</th>
<th scope="col" class="left">Oct2Py</th>
<th scope="col" class="left">MEfP</th>
<th scope="col" class="left">Matlab</th>
<th scope="col" class="left">Numpy</th>
<th scope="col" class="left">Octave</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">startup</td>
<td class="left">5.2 s</td>
<td class="left">5.8 s</td>
<td class="left">11 ms</td>
<td class="left">4.6 s</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">sum(randn(1,1))</td>
<td class="left">3.36 ms</td>
<td class="left">34.2 ms</td>
<td class="left">29.6 ms</td>
<td class="left">1.8 ms</td>
<td class="left">9.6 μs</td>
<td class="left">1.8 μs</td>
<td class="left">6 μs</td>
</tr>

<tr>
<td class="left">sum(randn(1,10))</td>
<td class="left">4.34 ms</td>
<td class="left">35.8 ms</td>
<td class="left">30.5 ms</td>
<td class="left">1.8 ms</td>
<td class="left">1.8 μs</td>
<td class="left">1.8 μs</td>
<td class="left">9 μs</td>
</tr>

<tr>
<td class="left">sum(randn(1,100))</td>
<td class="left">3.31 ms</td>
<td class="left">33.9 ms</td>
<td class="left">29.5 ms</td>
<td class="left">2.06 ms</td>
<td class="left">2.2 μs</td>
<td class="left">1.8 μs</td>
<td class="left">9 μs</td>
</tr>

<tr>
<td class="left">sum(randn(1,1000))</td>
<td class="left">3.27 ms</td>
<td class="left">32.7 ms</td>
<td class="left">30.6 ms</td>
<td class="left">9.1 ms</td>
<td class="left">4.1 μs</td>
<td class="left">2.3 μs</td>
<td class="left">12 μs</td>
</tr>

<tr>
<td class="left">sum(randn(1,1e4))</td>
<td class="left">7.43 ms</td>
<td class="left">34.5 ms</td>
<td class="left">30 ms</td>
<td class="left">72.2 ms</td>
<td class="left">25 μs</td>
<td class="left">5.8 μs</td>
<td class="left">38 μs</td>
</tr>

<tr>
<td class="left">sum(randn(1,1e5))</td>
<td class="left">15.6 ms</td>
<td class="left">86.1 ms</td>
<td class="left">31.2 ms</td>
<td class="left">712 ms</td>
<td class="left">55 μs</td>
<td class="left">38.6 μs</td>
<td class="left">280 μs</td>
</tr>

<tr>
<td class="left">sum(randn(1,1e6))</td>
<td class="left">405 ms</td>
<td class="left">874 ms</td>
<td class="left">45.7 ms</td>
<td class="left">7.21 a</td>
<td class="left">430 μs</td>
<td class="left">355 μs</td>
<td class="left">2.2 ms</td>
</tr>

<tr>
<td class="left">sum(randn(1,1e7))</td>
<td class="left">7.05 s</td>
<td class="left">10.6 s</td>
<td class="left">643 ms</td>
<td class="left">72 s</td>
<td class="left">3.5 ms</td>
<td class="left">5.04 ms</td>
<td class="left">22 ms</td>
</tr>
</tbody>
</table>
<div class="post-date">15 Jun 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-06-15-matlab-live-scripts.html">Teaching with Matlab Live Scripts</a></h1>
<p>
For a few years now, I have been teaching programming courses using <i>notebooks</i>. A notebook is an interactive document that can contain code, results, graphs, math, and prose. It is the perfect teaching tool:
</p>

<p>
You can combine introductory resources with application examples, assignments, and results. And after the lecture, students can refer to these notebooks at their leisure, and re-run example code, or try different approaches with known data.
</p>

<p>
The first time I saw this was with the <a href="http://jupyter.org/">Jupyter notebook</a> (née IPython notebook). I immediately used it for teaching an introductory programming course in Python.
</p>

<p>
Later, I took over a Matlab course, but Matlab lacked a notebook. So for the next two years of teaching Matlab, I hacked up a small IPython extension that allowed me to run Matlab code in an Jupyter notebook as a cell magic.
</p>

<p>
Now, with 2016a, Matlab introduced <a href="http://de.mathworks.com/help/releases/R2016a/matlab/live-scripts.html">Live Scripts</a>, which is Mathworkian for notebook. This blog post is about how Live Scripts compare to Jupyter notebooks.
</p>

<p>
First off, Live Scripts <i>work</i>. The basic functionality is there: Code, prose, figures, and math can be saved in one document; The notebook can be exported as PDF and HTML, and Students can download the notebook and play with it. This latter part was not possible with my homegrown solution earlier.
</p>

<p>
However, Live Scripts are new, and still contain a number of bugs. You can't customize figure sizes, formatting options are very basic, image rendering is terrible, and math rendering using LaTeX is of poor quality and limited. Also, using Live Scripts on a retina Mac is borderline impossible: Matlab crashes on screen resolution changes (i.e. connecting a projector), Live Scripts render REALLY slowly (type a word, watch the characters crawl onto the screen one by one), and all figures export in twice their intended size (fixed in 2016b). You can work around some of these issues by starting Matlab in <a href="https://support.apple.com/en-us/HT202471">Low Resolution Mode</a>.
</p>

<p>
No doubt some of these issues are going to get addressed in future releases. 2016b added script-local functions, which I read mostly as "you can now write functions in Live Scripts", and autocorrection-like text replacements that convert Markdown formatting into formatted text. This is highly appreciated.
</p>

<p>
Additionally though, here are a few features I would love to see:
</p>

<ul class="org-ul">
<li>Nested lists, and lists entries that contain newlines (i.e. differentiate between line breaks and paragraph breaks).
</li>
<li>Indented text, for quoting things, or to work around the lack of multi-line list entries.
</li>
<li>More headline levels.
</li>
<li>Magics. This is probably a long shot, but line/cell magics in Jupyter notebooks are really useful.
</li>
</ul>

<p>
Still, all griping aside, I want to reiterate that Live Scripts <i>work</i>. They aren't quite as nice as Jupyter notebooks, but they serve their purpose, and are a tremendously useful teaching tool.
</p>
<div class="post-date">31 May 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-05-31-Matlab-FFI.html">Matlab has an FFI and it is not Mex</a></h1>
<p>
Sometimes, you just have to use C code. There's no way around it. C is the lingua franca and bedrock of our computational world. Even in Matlab, sometimes, you just have to call into a C library.
</p>

<p>
So, you grab your towel, you bite the bullet, you strap into your K&amp;R, and get down to it: You start writing a Mex file. And you curse, and you cry, because writing C is hard, and Mex doesn't exactly make it any better. But you know what? <i>There is a better way!</i>
</p>

<p>
Because, unbeknownst to many, Matlab includes a Foreign Function Interface. The technique was probably pioneered by <a href="https://common-lisp.net/project/cffi/">Common Lisp</a>, and has since <a href="http://luajit.org/ext_ffi.html">been</a> <a href="http://cffi.readthedocs.io/en/latest/overview.html">widely</a> <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">adopted</a> <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">everywhere</a>: calling functions in a C library without writing any C code and without invoking a compiler!
</p>

<p>
Mind you, there remains a large and essential impedance mismatch between C's statically typed calling conventions and the vagaries of a dynamically typed language such as Matlab, and even the nicest FFI can't completely hide that fact. But anything is better than the abomination that is Mex.
</p>

<p>
So here goes, a very simple C library that adds two arrays:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #111111; font-style: italic;">// </span><span style="color: #111111; font-style: italic;">test.c:</span>
<span style="color: #111111;">#include</span> test.h

<span style="color: #111111; text-decoration: underline;">void</span> <span style="color: #111111; text-decoration: underline;">add_arrays</span>(<span style="color: #111111; text-decoration: underline;">float</span> *<span style="color: #111111;">out</span>, <span style="color: #111111; text-decoration: underline;">float</span>* <span style="color: #111111;">in</span>, <span style="color: #111111; text-decoration: underline;">size_t</span> <span style="color: #111111;">length</span>) {
    <span style="color: #111111; font-weight: bold;">for</span> (<span style="color: #111111; text-decoration: underline;">size_t</span> <span style="color: #111111;">n</span>=0; n&lt;length; n++) {
        out[n] += in[n];
    }
}

<span style="color: #111111; font-style: italic;">// </span><span style="color: #111111; font-style: italic;">test.h:</span>
<span style="color: #111111;">#include</span> <span style="color: #303030;">&lt;stddef.h&gt;</span>
<span style="color: #111111; text-decoration: underline;">void</span> <span style="color: #111111; text-decoration: underline;">add_arrays</span>(<span style="color: #111111; text-decoration: underline;">float</span> *<span style="color: #111111;">out</span>, <span style="color: #111111; text-decoration: underline;">float</span> *<span style="color: #111111;">in</span>, <span style="color: #111111; text-decoration: underline;">size_t</span> <span style="color: #111111;">length</span>);
</pre>
</div>

<p>
Let's compile it! <code>gcc -shared -std=c99 -o test.so test.c</code> will do the trick.
</p>

<p>
Now, let's load that library into Matlab with <code>loadlibrary</code>:
</p>

<div class="org-src-container">

<pre class="src src-octave"><span style="color: #111111; font-weight: bold;">if</span> not(libisloaded(<span style="color: #303030;">'test'</span>))
    [notfound<span style="color: #111111; background-color: #fffff8;">,</span> warnings] <span style="color: #111111; background-color: #fffff8;">=</span> loadlibrary(<span style="color: #303030;">'test.so'</span><span style="color: #111111; background-color: #fffff8;">,</span> <span style="color: #303030;">'test.h'</span>)<span style="color: #111111; background-color: #fffff8;">;</span>
    assert(isempty(notfound)<span style="color: #111111; background-color: #fffff8;">,</span> <span style="color: #303030;">'could not load test library'</span>)
<span style="color: #111111; font-weight: bold;">end</span>
</pre>
</div>

<p>
Note that <code>loadlibrary</code> can't parse many things you would commonly find in header files, so you will likely have to strip them down to the bare essentials. Additionally, <code>loadlibrary</code> doesn't throw errors if it can't load a library, so we always have to check the <code>notfound</code> output argument to see if the library was actually loaded successfully.
</p>

<p>
With that, we can call functions in that library using <code>calllib</code>. But we can't just pass in Matlab vectors, that would be too easy. We first have to convert them to something C can understand: Pointers
</p>

<div class="org-src-container">

<pre class="src src-octave">vector1 <span style="color: #111111; background-color: #fffff8;">=</span> [1 2 3 4 5]<span style="color: #111111; background-color: #fffff8;">;</span>
vector2 <span style="color: #111111; background-color: #fffff8;">=</span> [9 8 7 6 5]<span style="color: #111111; background-color: #fffff8;">;</span>

vector1ptr <span style="color: #111111; background-color: #fffff8;">=</span> libpointer(<span style="color: #303030;">'singlePointer'</span><span style="color: #111111; background-color: #fffff8;">,</span> vector1)<span style="color: #111111; background-color: #fffff8;">;</span>
vector2ptr <span style="color: #111111; background-color: #fffff8;">=</span> libpointer(<span style="color: #303030;">'singlePointer'</span><span style="color: #111111; background-color: #fffff8;">,</span> vector2)<span style="color: #111111; background-color: #fffff8;">;</span>
</pre>
</div>

<p>
What is nice about this is that this automatically converts the vectors from <code>double</code> to <code>float</code>. What is less nice is that it uses its weird <code>singlePtr</code> notation instead of the more canonical <code>float*</code> that you would expect from a self-respecting C header.
</p>

<p>
Then, finally, let's call our function:
</p>

<div class="org-src-container">

<pre class="src src-octave">calllib(<span style="color: #303030;">'test'</span><span style="color: #111111; background-color: #fffff8;">,</span> <span style="color: #303030;">'add_arrays'</span><span style="color: #111111; background-color: #fffff8;">,</span> vector1ptr<span style="color: #111111; background-color: #fffff8;">,</span> vector2ptr<span style="color: #111111; background-color: #fffff8;">,</span> length(vector1))<span style="color: #111111; background-color: #fffff8;">;</span>
</pre>
</div>

<p>
If you see no errors, everything went smoothly, and you will now have changed the content of vector1ptr, which we can have a look at like this:
</p>

<div class="org-src-container">

<pre class="src src-octave">added_vectors <span style="color: #111111; background-color: #fffff8;">=</span> vector1ptr.Value<span style="color: #111111; background-color: #fffff8;">;</span>
</pre>
</div>

<p>
Note that this didn't change the contents of <code>vector1</code>, only of the newly created pointer. So there will always be some memory overhead to this technique in comparison to Mex files. However, runtime overhead seems pretty fine:
</p>

<div class="org-src-container">

<pre class="src src-octave">timeit(@() calllib(<span style="color: #303030;">'test'</span><span style="color: #111111; background-color: #fffff8;">,</span> <span style="color: #303030;">'add_arrays'</span><span style="color: #111111; background-color: #fffff8;">,</span> vector1ptr<span style="color: #111111; background-color: #fffff8;">,</span> vector2ptr<span style="color: #111111; background-color: #fffff8;">,</span> length(vector1)))
<span style="color: #111111; font-style: italic;">%   </span><span style="color: #111111; font-style: italic;">ans = 1.9155e-05</span>
timeit(@() the_same_thing_but_as_a_mex_file(single(vector1)<span style="color: #111111; background-color: #fffff8;">,</span> single(vector2)))
<span style="color: #111111; font-style: italic;">%   </span><span style="color: #111111; font-style: italic;">ans = 4.6262e-05</span>
timeit(@() the_same_thing_plus_argument_conversion(vector1<span style="color: #111111; background-color: #fffff8;">,</span> vector2))
<span style="color: #111111; font-style: italic;">%   </span><span style="color: #111111; font-style: italic;">ans = 1.2326e-04</span>
</pre>
</div>

<p>
So as you can see, the <code>calllib</code> is plenty fast. However, if you add the Matlab code for converting the double arrays to pointers and extracting the summed data afterwards, the FFI is noticeably slower than a Mex file.
</p>

<p>
However, If I ask myself whether I would sacrifice 0.00007 seconds of computational overhead for hours of my life <i>not</i> spent with Mex, there really is no competition. I will choose Matlab's FFI over writing Mex files every time.
</p>
<div class="post-date">30 May 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-05-30-matplotlib-font-cache.html">Updating the Matplotlib Font Cache</a></h1>
<p>
When publishing papers or articles, I want my plots to integrate with the text surrounding them. I want them to use the correct font size, and the correct font.
</p>

<p>
This is easy to do with Matplotlib:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #111111; font-weight: bold;">import</span> matplotlib
<span style="color: #111111;">matplotlib.rcParams</span>[<span style="color: #303030;">'font.size'</span>] = 12
<span style="color: #111111;">matplotlib.rcParams</span>[<span style="color: #303030;">'font.family'</span>] = <span style="color: #303030;">'Calibri'</span>
</pre>
</div>

<p>
However, sometimes, Matplotlib won't find the correct, even though it is clearly installed. This happens when Matplotlib's internal font cache is out of date.
</p>

<p>
To refresh the font cache, use
</p>

<div class="org-src-container">

<pre class="src src-python">matplotlib.font_manager._rebuild()
</pre>
</div>

<p>
Happy Plotting!
</p>
<div class="post-date">13 Mar 2016</div><h1 class="post-title"><a href="http://bastibe.de/2016-03-13-code-quality-in-scientific-code.html">The Style of Scientific Code</a></h1>
<p>
What does quality code look like? One common school of thought focuses on small, descriptive functions that take few arguments. To quote from <a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin">Clean Code</a>: "The first rule of functions is that they should be small", on the order of less than ten lines. "Functions should not be large enough to hold nested structures". "The ideal number of arguments for a function is zero [, one, or two]. Three [or more] arguments should be avoided where possible".
</p>

<p>
A few years ago, when I was working mostly on user interaction and data management, all of this made sense to me. What is the overhead of a few function calls and class lookups here and there if it makes the code more readable? In other words: Readability counts, and is usually more important than performance.
</p>

<p>
But lately, I have come to struggle with these rules. I am now writing a lot of scientific code, where algorithms are intrinsically complex beyond the syntactic complexity of the code. How do you "Express yourself in code [instead of comments]", when that code only consists of linear algebra and matrix multiplications?
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #111111; font-weight: bold;">def</span> <span style="color: #111111; text-decoration: underline;">rectwin_spectrum</span>(angular_frequency, specsize):
    <span style="color: #303030;">"""The spectrum of a rectangular window. [...]"""</span>
    <span style="color: #111111; font-style: italic;"># </span><span style="color: #111111; font-style: italic;">In case of angular_frequency == 0, this will calculate NaN. Since</span>
    <span style="color: #111111; font-style: italic;"># </span><span style="color: #111111; font-style: italic;">this will be corrected later, suppress the warning.</span>
    <span style="color: #111111; font-weight: bold;">with</span> np.errstate(invalid=<span style="color: #303030;">'ignore'</span>):
        <span style="color: #111111;">spectrum</span> = ( np.exp(-1j*angular_frequency*(specsize-1)/2) *
                     np.sin(specsize*angular_frequency/2) /
                     np.sin(angular_frequency/2) )
    <span style="color: #111111; font-style: italic;"># </span><span style="color: #111111; font-style: italic;">since sin(x) == x for small x, the above expression</span>
    <span style="color: #111111; font-style: italic;"># </span><span style="color: #111111; font-style: italic;">evaluates to specsize for angular_frequency == 0.</span>
    <span style="color: #111111;">spectrum</span>[angular_frequency == 0.0] = specsize
    <span style="color: #111111; font-weight: bold;">return</span> spectrum
</pre>
</div>

<p>
A lot of my scientific code ends up quite compact like that. Maybe a hundred lines of dense numeric expressions, plus a few hundred lines of explanations and documentation. The point is, scientific code often does not decompose into easily understood extractable functions.
</p>

<p>
On a related issue, how do you avoid long argument lists in heavily parametrized equations? As Clean Code states, "when a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped in a class of their own". However, in Matlab in particular, it is quite unusual to create small one-trick classes to encapsulate a few function arguments:
</p>

<div class="org-src-container">

<pre class="src src-octave"><span style="color: #111111; font-weight: bold;">classdef</span> SignalBlocks <span style="color: #111111; background-color: #fffff8;">&lt;</span> handle
    <span style="color: #111111; font-weight: bold;">properties</span>
        data
        samplerate
        blocksize
        hopsize
    <span style="color: #111111; font-weight: bold;">end</span>
    <span style="color: #111111; font-weight: bold;">properties</span> (Dependent)
        duration
    <span style="color: #111111; font-weight: bold;">end</span>
    <span style="color: #111111; font-weight: bold;">methods</span>
        <span style="color: #111111; font-weight: bold;">function</span> obj <span style="color: #111111; background-color: #fffff8;">=</span> <span style="color: #111111; text-decoration: underline;">SignalBlock</span>(data<span style="color: #111111; background-color: #fffff8;">,</span> samplerate<span style="color: #111111; background-color: #fffff8;">,</span> blocksize<span style="color: #111111; background-color: #fffff8;">,</span> hopsize)
            <span style="color: #111111; font-style: italic;">% blocksize and hopsize are optional. What a mess.</span>
            narginchk(2<span style="color: #111111; background-color: #fffff8;">,</span> 4)<span style="color: #111111; background-color: #fffff8;">;</span>
            obj.data <span style="color: #111111; background-color: #fffff8;">=</span> data<span style="color: #111111; background-color: #fffff8;">;</span>
            obj.samplerate <span style="color: #111111; background-color: #fffff8;">=</span> samplerate<span style="color: #111111; background-color: #fffff8;">;</span>
            <span style="color: #111111; font-weight: bold;">if</span> nargin <span style="color: #111111; background-color: #fffff8;">&gt;=</span> 3
                obj.blocksize <span style="color: #111111; background-color: #fffff8;">=</span> blocksize<span style="color: #111111; background-color: #fffff8;">;</span>
            <span style="color: #111111; font-weight: bold;">else</span>
                obj.blocksize <span style="color: #111111; background-color: #fffff8;">=</span> 2048<span style="color: #111111; background-color: #fffff8;">;</span>
            <span style="color: #111111; font-weight: bold;">end</span>
            <span style="color: #111111; font-weight: bold;">if</span> nargin <span style="color: #111111; background-color: #fffff8;">==</span> 4
                obj.hopsize <span style="color: #111111; background-color: #fffff8;">=</span> hopsize<span style="color: #111111; background-color: #fffff8;">;</span>
            <span style="color: #111111; font-weight: bold;">else</span>
                obj.hopsize <span style="color: #111111; background-color: #fffff8;">=</span> 1024<span style="color: #111111; background-color: #fffff8;">;</span>
            <span style="color: #111111; font-weight: bold;">end</span>
        <span style="color: #111111; font-weight: bold;">end</span>
        <span style="color: #111111; font-weight: bold;">function</span> time <span style="color: #111111; background-color: #fffff8;">=</span> <span style="color: #111111; text-decoration: underline;">get</span>.duration(obj)
            time <span style="color: #111111; background-color: #fffff8;">=</span> length(obj.data)<span style="color: #111111; background-color: #fffff8;">/</span>obj.samplerate<span style="color: #111111; background-color: #fffff8;">;</span>
        <span style="color: #111111; font-weight: bold;">end</span>
    <span style="color: #111111; font-weight: bold;">end</span>
<span style="color: #111111; font-weight: bold;">end</span>
</pre>
</div>

<p>
This is not just cumbersome to write and maintain, it is also slower than passing <code>data</code>, <code>samplerate</code>, <code>blocksize</code>, and <code>hopsize</code> to each function call individually (although the overhead has gotten considerably smaller in newer versions of Matlab). Additionally, there is often a large performance benefit of <i>not</i> extracting every function and <i>not</i> keeping intermediate values in variables. Thus, it's not just readability that is hard to maintain in scientific code. Performance is a problem, too.
</p>

<p>
The sad thing is, I don't know the answer to these questions. There have been a lot of discussions about coding style and code quality in our department lately, with the clear objective to clean up our code. But common code quality criteria don't seem to apply to scientific code all that well.
</p>

<p>
Do you have any idea how to progress from here?
</p>
<div id="archive">
  <a href="archive.html">Older posts</a>
</div>
</div>
</body>
